<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>C√¥ng C·ª• M√¥ Ph·ªèng T√¢m ƒê·ªëi X·ª©ng</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            overscroll-behavior: none; /* NgƒÉn k√©o trang tr√™n mobile */
        }
        .tab-btn.active {
            background-color: #eff6ff;
            color: #2563eb;
            border-bottom: 2px solid #2563eb;
        }
        .shape-btn.active {
            background-color: #dbeafe;
            border-color: #3b82f6;
            color: #1d4ed8;
            font-weight: bold;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        /* Background Grid Pattern */
        .bg-grid-pattern {
            background-image: linear-gradient(#e5e7eb 1px, transparent 1px), linear-gradient(90deg, #e5e7eb 1px, transparent 1px);
            background-size: 20px 20px;
        }
        /* Slider styling - TƒÉng k√≠ch th∆∞·ªõc ƒë·ªÉ d·ªÖ k√©o c·∫£m ·ª©ng */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
            height: 24px;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px; width: 24px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            margin-top: -10px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer; background: #cbd5e1;
            border-radius: 2px;
        }
        /* Touch action fix */
        #main-svg {
            touch-action: none; /* Quan tr·ªçng: NgƒÉn cu·ªôn trang khi ch·∫°m v√†o canvas */
        }
    </style>
</head>
<body class="bg-gray-50 h-screen flex flex-col md:flex-row p-2 md:p-4 gap-4 overflow-hidden select-none text-gray-800">

    <!-- SIDEBAR CONTROL -->
    <div class="w-full md:w-1/3 bg-white rounded-xl shadow-lg flex flex-col h-full overflow-hidden border border-gray-100 z-10">
        
        <!-- Tabs Header -->
        <div class="flex border-b shrink-0 bg-gray-50">
            <button onclick="switchTab('simulation')" id="tab-simulation" class="tab-btn active flex-1 py-3 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500">
                <i data-lucide="rotate-ccw" class="w-5 h-5"></i> M√¥ Ph·ªèng
            </button>
            <button onclick="switchTab('drawing')" id="tab-drawing" class="tab-btn flex-1 py-3 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500">
                <i data-lucide="pen-tool" class="w-5 h-5"></i> Ph√≤ng Tranh
            </button>
            <button onclick="switchTab('game')" id="tab-game" class="tab-btn flex-1 py-3 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500">
                <i data-lucide="grid-3x3" class="w-5 h-5"></i> Th·ª≠ Th√°ch
            </button>
        </div>

        <!-- Content Area -->
        <div class="p-4 md:p-6 flex-1 overflow-y-auto relative bg-white">
            
            <!-- SECTION: SIMULATION -->
            <div id="content-simulation" class="space-y-5">
                <div class="bg-blue-50 p-3 rounded-lg border border-blue-100 text-sm text-blue-800">
                    <p class="font-semibold mb-1">üí° H∆∞·ªõng d·∫´n:</p>
                    <ul class="list-disc list-inside text-xs space-y-1">
                        <li>Ch·ªçn h√¨nh b√™n d∆∞·ªõi.</li>
                        <li>K√©o thanh tr∆∞·ª£t ho·∫∑c b·∫•m <strong>Play</strong> ƒë·ªÉ xoay 180¬∞.</li>
                        <li>Quan s√°t xem h√¨nh c√≥ <strong>tr√πng kh√≠t</strong> v·ªõi b√≥ng m·ªù ban ƒë·∫ßu kh√¥ng.</li>
                    </ul>
                </div>
                
                <div class="grid grid-cols-2 gap-2" id="shape-buttons">
                    <!-- Buttons generated by JS -->
                </div>

                <!-- Control Panel -->
                <div class="bg-gray-50 p-4 rounded-xl border border-gray-200 shadow-sm">
                    <div class="flex justify-between items-center mb-2">
                        <label class="text-xs font-bold text-gray-500 uppercase">G√≥c quay</label>
                        <span id="rotation-display" class="text-blue-600 font-bold text-lg font-mono">0¬∞</span>
                    </div>
                    
                    <div class="flex items-center gap-4">
                        <button onclick="togglePlay()" id="btn-play" class="w-12 h-12 flex-shrink-0 rounded-full text-white shadow-lg bg-green-500 hover:bg-green-600 active:scale-95 transition-transform flex items-center justify-center">
                            <i data-lucide="play" class="w-6 h-6 fill-current"></i>
                        </button>
                        <div class="flex-1 relative pt-2 pb-2">
                            <input type="range" id="rotation-slider" min="0" max="180" value="0" class="w-full align-middle">
                            <div class="flex justify-between text-[10px] font-bold text-gray-400 mt-1 px-1">
                                <span>0¬∞</span>
                                <span>90¬∞</span>
                                <span>180¬∞</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Feedback Area -->
                <div id="sim-feedback" class="hidden p-3 rounded-lg text-sm font-medium text-center transition-all duration-300">
                    <!-- Text will be injected here -->
                </div>

                <div class="flex items-center gap-3 bg-gray-50 p-2 rounded-lg">
                    <input type="checkbox" id="chk-show-labels" checked class="w-5 h-5 text-blue-600 rounded focus:ring-blue-500">
                    <label for="chk-show-labels" class="text-sm cursor-pointer select-none font-medium text-gray-700">Hi·ªán t√™n ƒë·ªânh (A, B...)</label>
                </div>
                
                <button onclick="resetSimulation()" class="w-full py-3 bg-gray-100 hover:bg-gray-200 text-gray-700 rounded-xl text-sm font-bold flex justify-center items-center gap-2 transition-colors">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i> ƒê·∫∑t l·∫°i v·ªã tr√≠ t√¢m
                </button>
            </div>

            <!-- SECTION: DRAWING -->
            <div id="content-drawing" class="space-y-6 hidden">
                <div class="bg-indigo-50 p-4 rounded-xl text-sm text-indigo-900 border border-indigo-200">
                    <h4 class="font-bold flex items-center gap-2 mb-1"><i data-lucide="wand-2" class="w-4 h-4"></i> V·∫Ω ƒê·ªëi X·ª©ng</h4>
                    <p>H√£y v·∫Ω m·ªôt n·ª≠a b√¥ng hoa ho·∫∑c m·ªôt con b∆∞·ªõm ·ªü b√™n tr√°i. M√°y t√≠nh s·∫Ω gi√∫p b·∫°n v·∫Ω n·ª≠a c√≤n l·∫°i ƒë·ªëi x·ª©ng qua t√¢m O!</p>
                </div>

                <div class="space-y-3">
                    <label class="text-sm font-bold text-gray-700">Ch·ªçn m√†u b√∫t:</label>
                    <div class="flex gap-3 justify-center" id="color-palette">
                        <!-- Colors generated by JS -->
                    </div>
                </div>

                <button onclick="clearDrawing()" class="w-full py-3 bg-red-50 hover:bg-red-100 text-red-600 border border-red-200 rounded-xl font-bold flex justify-center items-center gap-2 transition-colors">
                    <i data-lucide="eraser" class="w-5 h-5"></i> X√≥a b·∫£ng v·∫Ω l·∫°i
                </button>
            </div>

            <!-- SECTION: GAME -->
            <div id="content-game" class="space-y-6 hidden">
                <div class="flex justify-between items-center bg-gray-50 p-2 rounded-lg border">
                    <h3 class="font-bold text-lg text-gray-700 pl-2">C·∫•p ƒë·ªô <span id="level-display" class="text-blue-600">1</span></h3>
                    <div class="flex gap-1">
                        <button onclick="changeLevel(-1)" class="w-8 h-8 flex items-center justify-center bg-white border rounded shadow-sm hover:bg-gray-50 font-bold text-gray-600">-</button>
                        <button onclick="changeLevel(1)" class="w-8 h-8 flex items-center justify-center bg-white border rounded shadow-sm hover:bg-gray-50 font-bold text-gray-600">+</button>
                    </div>
                </div>

                <div class="bg-green-50 p-4 rounded-xl text-green-900 border border-green-200 text-sm">
                    <p class="leading-relaxed"><strong>Nhi·ªám v·ª•:</strong> M√°y ƒë√£ t√¥ s·∫µn c√°c √¥ m√†u xanh d∆∞∆°ng <span class="inline-block w-3 h-3 bg-blue-400 rounded-sm align-middle"></span>. B·∫°n h√£y t√¨m v√† t√¥ c√°c √¥ ƒë·ªëi x·ª©ng v·ªõi n√≥ qua t√¢m ƒë·ªè.</p>
                </div>

                <div id="game-message" class="hidden bg-yellow-100 p-4 rounded-xl border border-yellow-300 text-center animate-bounce">
                    <div class="flex justify-center mb-2"><i data-lucide="trophy" class="w-10 h-10 text-yellow-600 fill-current"></i></div>
                    <p class="font-bold text-yellow-800 text-lg">Ch√≠nh x√°c! Tuy·ªát v·ªùi!</p>
                    <button onclick="initGame()" class="mt-3 px-6 py-2 bg-yellow-500 text-white rounded-full font-bold shadow-lg hover:bg-yellow-600 transform active:scale-95 transition-all">Ch∆°i m√†n ti·∫øp theo</button>
                </div>
                
                <button onclick="initGame()" class="w-full py-3 border-2 border-dashed border-gray-300 hover:border-blue-400 hover:bg-blue-50 text-gray-500 hover:text-blue-600 rounded-xl font-bold flex justify-center items-center gap-2 text-sm transition-all">
                    <i data-lucide="shuffle" class="w-4 h-4"></i> ƒê·ªïi ƒë·ªÅ b√†i kh√°c
                </button>
            </div>
        </div>
    </div>

    <!-- CANVAS AREA -->
    <div class="flex-1 bg-white rounded-xl shadow-lg relative overflow-hidden flex items-center justify-center border-2 border-gray-100">
        
        <!-- Background Grid (Hidden in Game Mode) -->
        <div id="bg-grid" class="absolute inset-0 opacity-20 pointer-events-none bg-grid-pattern"></div>
        
        <!-- Simulation & Drawing SVG -->
        <svg id="main-svg" width="800" height="800" viewBox="0 0 800 800" class="max-w-full max-h-full cursor-crosshair touch-none select-none">
            <!-- Markers definition -->
            <defs>
                <filter id="glow" x="-20%" y="-20%" width="140%" height="140%">
                    <feGaussianBlur stdDeviation="3" result="blur" />
                    <feComposite in="SourceGraphic" in2="blur" operator="over" />
                </filter>
            </defs>
            <!-- Content will be rendered here by JS -->
        </svg>

        <!-- Mode Indicator & Instructions -->
        <div class="absolute bottom-4 left-0 right-0 text-center pointer-events-none">
            <span id="canvas-hint" class="bg-white/90 backdrop-blur-sm px-4 py-2 rounded-full text-sm text-gray-600 shadow-sm border border-gray-200 inline-block">
                K√©o ƒëi·ªÉm ƒë·ªè O ƒë·ªÉ thay ƒë·ªïi t√¢m
            </span>
        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const CANVAS_SIZE = 800; // ƒê√£ tƒÉng k√≠ch th∆∞·ªõc l√™n 800
        const CENTER_COORD = CANVAS_SIZE / 2; // = 400
        const GRID_SIZE = 8;
        const CELL_SIZE = 60; // TƒÉng k√≠ch th∆∞·ªõc √¥ cho ph√π h·ª£p canvas m·ªõi
        const GAME_OFFSET_X = (CANVAS_SIZE - GRID_SIZE * CELL_SIZE) / 2;
        const GAME_OFFSET_Y = (CANVAS_SIZE - GRID_SIZE * CELL_SIZE) / 2;

        // C√°c h√¨nh ƒë∆∞·ª£c scale to h∆°n ƒë·ªÉ ph√π h·ª£p v·ªõi Canvas 800x800
        const shapes = {
            parallelogram: {
                name: "H√¨nh b√¨nh h√†nh",
                type: 'polygon', hasSymmetry: true,
                getPoints: (cx, cy) => [ {x:cx-160, y:cy-96, label:'A'}, {x:cx+64, y:cy-96, label:'B'}, {x:cx+160, y:cy+96, label:'C'}, {x:cx-64, y:cy+96, label:'D'} ]
            },
            rectangle: {
                name: "H√¨nh ch·ªØ nh·∫≠t",
                type: 'polygon', hasSymmetry: true,
                getPoints: (cx, cy) => [ {x:cx-160, y:cy-96, label:'A'}, {x:cx+160, y:cy-96, label:'B'}, {x:cx+160, y:cy+96, label:'C'}, {x:cx-160, y:cy+96, label:'D'} ]
            },
            triangle: {
                name: "Tam gi√°c ƒë·ªÅu",
                type: 'polygon', hasSymmetry: false,
                isTriangle: true, // Marker for special logic
                getPoints: (cx, cy) => [ {x:cx, y:cy-144, label:'A'}, {x:cx+125, y:cy+72, label:'B'}, {x:cx-125, y:cy+72, label:'C'} ]
            },
            flower: {
                name: "C√°nh hoa (4 c√°nh)",
                type: 'path', hasSymmetry: true,
                // M·ªôt h√¨nh hoa ƒë∆°n gi·∫£n
                pathD: "M 0 -10 C -20 -40 -60 -40 -60 -10 C -60 20 -20 20 0 10 C 20 20 60 20 60 -10 C 60 -40 20 -40 0 -10 Z"
            }
        };

        const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'];

        // --- STATE ---
        let state = {
            tab: 'simulation', // simulation, drawing, game
            center: { x: CENTER_COORD, y: CENTER_COORD },
            
            // Simulation
            shapeType: 'parallelogram',
            rotation: 0,
            isPlaying: false,
            showLabels: true,

            // Drawing
            drawPaths: [], // [{points: [], color: ''}]
            currentPath: [],
            drawingColor: '#3B82F6',
            isDrawing: false,

            // Game
            level: 1,
            grid: [], // 2D array
            gameStatus: 'playing' // playing, won
        };

        let isDraggingCenter = false;
        let animationId = null;

        // --- DOM ELEMENTS ---
        const svgEl = document.getElementById('main-svg');
        const sliderEl = document.getElementById('rotation-slider');
        const rotationDisplayEl = document.getElementById('rotation-display');
        const btnPlayEl = document.getElementById('btn-play');
        const bgGridEl = document.getElementById('bg-grid');
        const feedbackEl = document.getElementById('sim-feedback');
        const canvasHintEl = document.getElementById('canvas-hint');

        // --- INITIALIZATION ---
        function init() {
            lucide.createIcons();
            renderShapeButtons();
            renderColorPalette();
            initGame(); 
            renderCanvas();

            // Slider Event
            sliderEl.addEventListener('input', (e) => {
                state.rotation = parseInt(e.target.value);
                state.isPlaying = false;
                updateUI();
                renderCanvas();
                checkSimulationStatus();
            });

            // SVG Events - Unified Pointer Events
            svgEl.addEventListener('pointerdown', handlePointerDown);
            svgEl.addEventListener('pointermove', handlePointerMove);
            svgEl.addEventListener('pointerup', handlePointerUp);
            svgEl.addEventListener('pointerleave', handlePointerUp);

            document.getElementById('chk-show-labels').addEventListener('change', (e) => {
                state.showLabels = e.target.checked;
                renderCanvas();
            });
        }

        // --- TABS LOGIC ---
        window.switchTab = function(tabName) {
            state.tab = tabName;
            state.isPlaying = false;
            state.rotation = 0;
            
            // Update UI Tabs
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Show/Hide Content Areas
            ['simulation', 'drawing', 'game'].forEach(t => {
                const el = document.getElementById(`content-${t}`);
                if (t === tabName) el.classList.remove('hidden');
                else el.classList.add('hidden');
            });

            // Grid & Hints
            if (tabName === 'game') {
                bgGridEl.style.display = 'none';
                canvasHintEl.style.display = 'none';
            } else if (tabName === 'drawing') {
                bgGridEl.style.display = 'block';
                canvasHintEl.style.display = 'none';
                state.center = {x: CENTER_COORD, y: CENTER_COORD};
            } else {
                bgGridEl.style.display = 'block';
                canvasHintEl.style.display = 'inline-block';
                canvasHintEl.innerText = "K√©o ƒëi·ªÉm ƒë·ªè O ƒë·ªÉ thay ƒë·ªïi t√¢m xoay";
                state.center = {x: CENTER_COORD, y: CENTER_COORD};
            }

            renderCanvas();
            updateUI();
            checkSimulationStatus();
        };

        // --- SIMULATION LOGIC ---
        function renderShapeButtons() {
            const container = document.getElementById('shape-buttons');
            container.innerHTML = '';
            for (const [key, shape] of Object.entries(shapes)) {
                const btn = document.createElement('button');
                btn.className = `shape-btn p-3 rounded-xl text-sm border border-gray-200 bg-white hover:bg-gray-50 transition-all ${state.shapeType === key ? 'active' : ''}`;
                btn.innerText = shape.name;
                btn.onclick = () => {
                    state.shapeType = key;
                    state.rotation = 0;
                    state.isPlaying = false;
                    state.center = {x: CENTER_COORD, y: CENTER_COORD}; // Reset center when changing shape
                    renderShapeButtons();
                    updateUI();
                    renderCanvas();
                    checkSimulationStatus();
                };
                container.appendChild(btn);
            }
        }

        window.togglePlay = function() {
            state.isPlaying = !state.isPlaying;
            updateUI();
            if (state.isPlaying) animate();
            else cancelAnimationFrame(animationId);
        };

        window.resetSimulation = function() {
            state.center = {x: CENTER_COORD, y: CENTER_COORD};
            state.rotation = 0;
            state.isPlaying = false;
            updateUI();
            renderCanvas();
            checkSimulationStatus();
        };

        function animate() {
            if (!state.isPlaying) return;
            state.rotation += 1; // TƒÉng t·ªëc ƒë·ªô m·ªôt ch√∫t
            if (state.rotation >= 180) {
                state.rotation = 180;
                state.isPlaying = false;
            }
            updateUI();
            renderCanvas();
            checkSimulationStatus();
            if (state.isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function checkSimulationStatus() {
            if (state.tab !== 'simulation') return;
            
            const shape = shapes[state.shapeType];
            const isAt180 = state.rotation === 180;
            const isCenterCorrect = Math.abs(state.center.x - CENTER_COORD) < 5 && Math.abs(state.center.y - CENTER_COORD) < 5;

            feedbackEl.className = "hidden p-3 rounded-lg text-sm font-medium text-center transition-all duration-300";

            if (state.rotation > 0) {
                feedbackEl.classList.remove('hidden');
                
                if (isAt180) {
                    if (shape.hasSymmetry && isCenterCorrect) {
                        feedbackEl.classList.add('bg-green-100', 'text-green-800', 'border', 'border-green-200');
                        feedbackEl.innerHTML = `<span class="flex justify-center items-center gap-2"><i data-lucide="check-circle" class="w-5 h-5"></i> <strong>Ch√≠nh x√°c!</strong> H√¨nh tr√πng kh√≠t 100%.</span>`;
                        lucide.createIcons();
                    } else if (!shape.hasSymmetry) {
                        feedbackEl.classList.add('bg-red-100', 'text-red-800', 'border', 'border-red-200');
                        feedbackEl.innerHTML = `<span class="flex justify-center items-center gap-2"><i data-lucide="alert-triangle" class="w-5 h-5"></i> <strong>Kh√¥ng tr√πng kh√≠t!</strong><br>H√¨nh n√†y kh√¥ng c√≥ t√¢m ƒë·ªëi x·ª©ng.</span>`;
                        lucide.createIcons();
                    } else if (!isCenterCorrect) {
                        feedbackEl.classList.add('bg-orange-100', 'text-orange-800', 'border', 'border-orange-200');
                        feedbackEl.innerText = "H√¨nh ch∆∞a tr√πng kh√≠t v√¨ T√¢m quay ch∆∞a ƒë√∫ng. H√£y k√©o ƒëi·ªÉm O v·ªÅ ch√≠nh gi·ªØa h√¨nh.";
                    }
                } else {
                    feedbackEl.classList.add('bg-gray-100', 'text-gray-600');
                    feedbackEl.innerText = `ƒêang xoay ${state.rotation}¬∞... H√£y xoay ƒë·∫øn 180¬∞.`;
                }
            }
        }

        function updateUI() {
            sliderEl.value = state.rotation;
            rotationDisplayEl.innerText = state.rotation + "¬∞";
            
            btnPlayEl.innerHTML = state.isPlaying 
                ? '<i data-lucide="pause" class="w-6 h-6 fill-current"></i>' 
                : '<i data-lucide="play" class="w-6 h-6 fill-current"></i>';
            if(state.isPlaying) {
                btnPlayEl.classList.add('bg-orange-500', 'hover:bg-orange-600');
                btnPlayEl.classList.remove('bg-green-500', 'hover:bg-green-600');
            } else {
                btnPlayEl.classList.remove('bg-orange-500', 'hover:bg-orange-600');
                btnPlayEl.classList.add('bg-green-500', 'hover:bg-green-600');
            }
            
            lucide.createIcons();
            
            // Game UI
            document.getElementById('level-display').innerText = state.level;
            const gameMsg = document.getElementById('game-message');
            
            if (state.gameStatus === 'won') {
                gameMsg.classList.remove('hidden');
            } else {
                gameMsg.classList.add('hidden');
            }
        }

        // --- DRAWING LOGIC ---
        function renderColorPalette() {
            const container = document.getElementById('color-palette');
            colors.forEach(c => {
                const btn = document.createElement('button');
                btn.className = 'w-10 h-10 rounded-full border-4 border-white shadow-md hover:scale-110 transition-transform';
                btn.style.backgroundColor = c;
                if(state.drawingColor === c) btn.style.borderColor = '#cbd5e1';
                btn.onclick = () => {
                    state.drawingColor = c;
                    renderColorPalette(); 
                };
                container.appendChild(btn);
            });
        }

        window.clearDrawing = function() {
            state.drawPaths = [];
            state.currentPath = [];
            renderCanvas();
        };

        // --- GAME LOGIC ---
        window.changeLevel = function(delta) {
            let newLevel = state.level + delta;
            if (newLevel < 1) newLevel = 1;
            if (newLevel > 10) newLevel = 10;
            state.level = newLevel;
            initGame();
            updateUI();
        };

        window.initGame = function() {
            let grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            const numPairs = 3 + state.level; 
            let count = 0;

            while (count < numPairs) {
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);
                const symR = GRID_SIZE - 1 - r;
                const symC = GRID_SIZE - 1 - c;

                // Tr√°nh t√¢m c·ªßa l∆∞·ªõi (n·∫øu l∆∞·ªõi l·∫ª) v√† √¥ ƒë√£ t√¥
                if (grid[r][c] === 0 && grid[symR][symC] === 0) {
                    grid[r][c] = 1; // Machine set
                    count++;
                }
            }
            state.grid = grid;
            state.gameStatus = 'playing';
            updateUI();
            renderCanvas();
        };

        function handleGameClick(x, y) {
            if (state.gameStatus === 'won') return;
            
            if (x < GAME_OFFSET_X || x > GAME_OFFSET_X + GRID_SIZE * CELL_SIZE ||
                y < GAME_OFFSET_Y || y > GAME_OFFSET_Y + GRID_SIZE * CELL_SIZE) return;

            const c = Math.floor((x - GAME_OFFSET_X) / CELL_SIZE);
            const r = Math.floor((y - GAME_OFFSET_Y) / CELL_SIZE);

            if (state.grid[r][c] === 1) return; // Cannot toggle question cells

            state.grid[r][c] = state.grid[r][c] === 2 ? 0 : 2;
            
            checkWin();
            renderCanvas();
        }

        function checkWin() {
            let isFullSymmetry = true;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const val = state.grid[r][c];
                    const symVal = state.grid[GRID_SIZE-1-r][GRID_SIZE-1-c];
                    if (val !== 0 && symVal === 0) isFullSymmetry = false;
                }
            }
            if (isFullSymmetry) {
                state.gameStatus = 'won';
                updateUI();
            }
        }

        // --- MAIN RENDERER (SVG) ---
        function renderCanvas() {
            svgEl.innerHTML = '<defs><filter id="glow" x="-20%" y="-20%" width="140%" height="140%"><feGaussianBlur stdDeviation="3" result="blur" /><feComposite in="SourceGraphic" in2="blur" operator="over" /></filter></defs>'; 

            if (state.tab === 'simulation') renderSimulationMode();
            else if (state.tab === 'drawing') renderDrawingMode();
            else if (state.tab === 'game') renderGameMode();

            // Draw Center O
            if (state.tab !== 'game') {
                const g = createSVGElement('g', {
                    transform: `translate(${state.center.x}, ${state.center.y})`,
                    class: 'cursor-move',
                    style: 'cursor: move'
                });
                // Big transparent Hitbox for easier touch
                g.appendChild(createSVGElement('circle', { r: 30, fill: 'transparent' })); 
                // Visual dot
                g.appendChild(createSVGElement('circle', { 
                    r: isDraggingCenter ? 10 : 7, 
                    fill: '#ef4444', 
                    stroke: 'white', 
                    'stroke-width': 2,
                    class: 'transition-all duration-200 shadow-sm'
                }));
                // Label
                const text = createSVGElement('text', { x: 12, y: -12, fill: '#ef4444', 'font-weight': 'bold', 'font-size': 16 });
                text.textContent = 'O';
                g.appendChild(text);
                svgEl.appendChild(g);
            }
        }

        function createSVGElement(tag, attrs) {
            const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
            for (const [key, value] of Object.entries(attrs)) {
                el.setAttribute(key, value);
            }
            return el;
        }

        function renderSimulationMode() {
            const shape = shapes[state.shapeType];
            const isAt180 = state.rotation === 180;
            const isCenterCorrect = Math.abs(state.center.x - CENTER_COORD) < 5 && Math.abs(state.center.y - CENTER_COORD) < 5;
            
            // 1. Static Ghost Shape (Lu√¥n c·ªë ƒë·ªãnh gi·ªØa m√†n h√¨nh ƒë·ªÉ l√†m m·ªëc)
            let ghostGroup = createSVGElement('g', {});
            if (shape.type === 'polygon') {
                const pts = shape.getPoints(CENTER_COORD, CENTER_COORD);
                const ptsStr = pts.map(p => `${p.x},${p.y}`).join(' ');
                ghostGroup.appendChild(createSVGElement('polygon', {
                    points: ptsStr, fill: '#f3f4f6', stroke: '#9CA3AF', 'stroke-width': 2, 'stroke-dasharray': '6,4'
                }));
                if(state.showLabels) {
                    pts.forEach(p => {
                         const t = createSVGElement('text', {x: p.x, y: p.y - 10, fill: '#9CA3AF', 'font-size': 12, 'text-anchor': 'middle'});
                         t.textContent = p.label;
                         ghostGroup.appendChild(t);
                    });
                }
            } else if (shape.type === 'path') {
                if(shape.name.includes("hoa")) {
                    // X·ª≠ l√Ω ri√™ng cho h√¨nh hoa ƒë·ªÉ scale to l√™n
                    const g = createSVGElement('g', { transform: `translate(${CENTER_COORD}, ${CENTER_COORD}) scale(4)` });
                    g.appendChild(createSVGElement('path', {
                         d: shape.pathD, stroke: '#9CA3AF', 'stroke-width': 1, fill: '#f3f4f6', 'stroke-dasharray': '4,2'
                    }));
                    ghostGroup.appendChild(g);
                }
            }
            svgEl.appendChild(ghostGroup);

            // 2. Rotating Shape
            let strokeColor = '#3B82F6'; // Blue default
            let fillColor = 'rgba(59, 130, 246, 0.4)';
            
            // ƒê·ªïi m√†u khi xoay xong
            if (isAt180) {
                 if (shape.hasSymmetry && isCenterCorrect) {
                     strokeColor = '#10B981'; // Green (Success)
                     fillColor = 'rgba(16, 185, 129, 0.5)';
                 } else if (!shape.hasSymmetry && isCenterCorrect) {
                     strokeColor = '#EF4444'; // Red (Error)
                     fillColor = 'rgba(239, 68, 68, 0.4)';
                 }
            }

            const rotG = createSVGElement('g', {
                transform: `rotate(${state.rotation}, ${state.center.x}, ${state.center.y})`,
                style: 'transition: transform 0.1s linear' // Smooth rotation
            });

            if (shape.type === 'polygon') {
                const pts = shape.getPoints(CENTER_COORD, CENTER_COORD);
                const ptsStr = pts.map(p => `${p.x},${p.y}`).join(' ');
                rotG.appendChild(createSVGElement('polygon', {
                    points: ptsStr, fill: fillColor, stroke: strokeColor, 'stroke-width': 3
                }));
                
                if(state.showLabels) {
                    pts.forEach(p => {
                         // Xoay ng∆∞·ª£c ch·ªØ ƒë·ªÉ n√≥ lu√¥n ƒë·ª©ng th·∫≥ng
                         const tGroup = createSVGElement('g', {transform: `translate(${p.x}, ${p.y-15})`});
                         const tRot = createSVGElement('text', {
                             fill: strokeColor, 'font-weight': 'bold', 'font-size': 14, 'text-anchor': 'middle',
                             transform: `rotate(${-state.rotation})` // Counter-rotate label
                         });
                         tRot.textContent = p.label + "'";
                         tGroup.appendChild(tRot);
                         rotG.appendChild(tGroup);
                    });
                }
            } else if (shape.type === 'path') {
                if(shape.name.includes("hoa")) {
                     const gInner = createSVGElement('g', { transform: `translate(${CENTER_COORD}, ${CENTER_COORD}) scale(4)` });
                     gInner.appendChild(createSVGElement('path', {
                         d: shape.pathD, stroke: strokeColor, 'stroke-width': 1.5, fill: fillColor
                     }));
                     rotG.appendChild(gInner);
                }
            }
            svgEl.appendChild(rotG);

            // 3. Highlight Vertices mismatch for Triangle (Visual Aid)
            if (isAt180 && shape.isTriangle && isCenterCorrect) {
                 // V·∫Ω ƒë∆∞·ªùng n·ªëi t·ª´ ƒë·ªânh A g·ªëc ƒë·∫øn ƒë·ªânh A' xoay
                 // ƒê∆°n gi·∫£n h√≥a: V·∫Ω ch·∫•m ƒë·ªè t·∫°i c√°c ƒë·ªânh c·ªßa h√¨nh xoay ƒë·ªÉ th·∫•y n√≥ l·ªách ra ngo√†i
                 const pts = shape.getPoints(CENTER_COORD, CENTER_COORD); // ƒêi·ªÉm g·ªëc
                 // T√≠nh ƒëi·ªÉm xoay
                 const rad = Math.PI; // 180 deg
                 const cx = CENTER_COORD; const cy = CENTER_COORD;
                 pts.forEach(p => {
                      const x1 = p.x - cx; const y1 = p.y - cy;
                      const x2 = x1 * Math.cos(rad) - y1 * Math.sin(rad) + cx;
                      const y2 = x1 * Math.sin(rad) + y1 * Math.cos(rad) + cy;
                      
                      svgEl.appendChild(createSVGElement('circle', {
                          cx: x2, cy: y2, r: 5, fill: '#EF4444', class: 'animate-pulse'
                      }));
                 });
            }
        }

        function renderDrawingMode() {
            // Helper to draw a polyline
            const drawPoly = (points, color, dashed = false) => {
                const ptsStr = points.map(p => `${p.x},${p.y}`).join(' ');
                svgEl.appendChild(createSVGElement('polyline', {
                    points: ptsStr, fill: 'none', stroke: color, 'stroke-width': dashed ? 2 : 4,
                    'stroke-linecap': 'round', 'stroke-linejoin': 'round',
                    'stroke-dasharray': dashed ? '6,6' : 'none', opacity: dashed ? 0.5 : 1
                }));
            };

            // Existing paths
            state.drawPaths.forEach(path => {
                drawPoly(path.points, path.color);
                // Symmetric
                const symPoints = path.points.map(p => ({ x: 2*state.center.x - p.x, y: 2*state.center.y - p.y }));
                drawPoly(symPoints, path.color, true);
            });

            // Current drawing
            if (state.currentPath.length > 0) {
                drawPoly(state.currentPath, state.drawingColor);
                const symPoints = state.currentPath.map(p => ({ x: 2*state.center.x - p.x, y: 2*state.center.y - p.y }));
                drawPoly(symPoints, state.drawingColor, true);
            }
        }

        function renderGameMode() {
            // Border & Background
            svgEl.appendChild(createSVGElement('rect', {
                x: GAME_OFFSET_X - 2, y: GAME_OFFSET_Y - 2, 
                width: GRID_SIZE * CELL_SIZE + 4, height: GRID_SIZE * CELL_SIZE + 4,
                fill: '#fff', stroke: '#e5e7eb', 'stroke-width': 1, rx: 4
            }));

            // Draw grid cells
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const x = GAME_OFFSET_X + c * CELL_SIZE;
                    const y = GAME_OFFSET_Y + r * CELL_SIZE;
                    
                    let fill = 'transparent';
                    let stroke = '#f3f4f6';
                    
                    if (state.grid[r][c] === 1) fill = '#60A5FA'; // Machine (Blue)
                    if (state.grid[r][c] === 2) fill = '#34D399'; // User (Green)
                    if (state.gameStatus === 'won' && state.grid[r][c] !== 0) fill = '#FBBF24'; // Win (Gold)

                    const rect = createSVGElement('rect', {
                        x: x, y: y, width: CELL_SIZE, height: CELL_SIZE,
                        fill: fill, stroke: stroke, 'stroke-width': 1
                    });
                    svgEl.appendChild(rect);
                }
            }
            
            // Grid Lines (Cleaner look)
            svgEl.appendChild(createSVGElement('rect', {
                x: GAME_OFFSET_X, y: GAME_OFFSET_Y, 
                width: GRID_SIZE * CELL_SIZE, height: GRID_SIZE * CELL_SIZE,
                fill: 'none', stroke: '#374151', 'stroke-width': 2, 'pointer-events': 'none'
            }));
            
            // Center Dot (Fixed)
            const cx = GAME_OFFSET_X + (GRID_SIZE * CELL_SIZE) / 2;
            const cy = GAME_OFFSET_Y + (GRID_SIZE * CELL_SIZE) / 2;
            svgEl.appendChild(createSVGElement('circle', { cx: cx, cy: cy, r: 8, fill: '#ef4444', stroke: 'white', 'stroke-width': 2, 'pointer-events': 'none' }));
        }

        // --- UNIFIED POINTER HANDLER (MOUSE & TOUCH) ---
        function getPointerPos(e) {
            const rect = svgEl.getBoundingClientRect();
            // Scale pointer coordinates based on canvas display size vs actual size (800)
            const scaleX = 800 / rect.width;
            const scaleY = 800 / rect.height;
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function handlePointerDown(e) {
            e.preventDefault(); // Prevent scrolling on touch
            const pos = getPointerPos(e);
            
            // Capture pointer for smooth dragging outside element
            svgEl.setPointerCapture(e.pointerId);

            if (state.tab === 'game') {
                handleGameClick(pos.x, pos.y);
                return;
            }

            // Check center drag - Increased hit radius to 40
            if (Math.abs(pos.x - state.center.x) < 40 && Math.abs(pos.y - state.center.y) < 40) {
                isDraggingCenter = true;
                // Snap to finger immediately for better feel
                state.center = pos; 
                renderCanvas();
                return;
            }

            if (state.tab === 'drawing') {
                state.isDrawing = true;
                state.currentPath = [pos];
            }
        }

        function handlePointerMove(e) {
            if (!isDraggingCenter && !state.isDrawing) return;
            e.preventDefault(); 
            const pos = getPointerPos(e);

            if (isDraggingCenter) {
                state.center = pos;
                renderCanvas();
                if(state.tab === 'simulation') {
                    // Reset rotation visual feedback when moving center
                    if(state.rotation === 180) state.rotation = 0; 
                    updateUI();
                }
                return;
            }

            if (state.tab === 'drawing' && state.isDrawing) {
                state.currentPath.push(pos);
                // Optimize rendering: only redraw if points added
                renderCanvas(); 
            }
        }

        function handlePointerUp(e) {
            e.preventDefault();
            svgEl.releasePointerCapture(e.pointerId);
            
            isDraggingCenter = false;
            if (state.tab === 'drawing' && state.isDrawing) {
                state.isDrawing = false;
                if (state.currentPath.length > 0) {
                    state.drawPaths.push({ points: state.currentPath, color: state.drawingColor });
                }
                state.currentPath = [];
                renderCanvas();
            }
            // Re-check status when dropping center
            if (state.tab === 'simulation') {
                checkSimulationStatus();
            }
            renderCanvas(); // Redraw to remove visual drag indicators
        }

        // Start
        init();

    </script>
</body>
</html>
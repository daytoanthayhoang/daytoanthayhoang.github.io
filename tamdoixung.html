<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Công Cụ Mô Phỏng Tâm Đối Xứng</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        .tab-btn.active {
            background-color: #eff6ff;
            color: #2563eb;
            border-bottom: 2px solid #2563eb;
        }
        .shape-btn.active {
            background-color: #dbeafe;
            border-color: #3b82f6;
            color: #1d4ed8;
            font-weight: bold;
        }
        /* Background Grid Pattern */
        .bg-grid-pattern {
            background-image: linear-gradient(#444 1px, transparent 1px), linear-gradient(90deg, #444 1px, transparent 1px);
            background-size: 20px 20px;
        }
        /* Slider styling */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px; width: 16px;
            border-radius: 50%;
            background: #2563eb;
            cursor: pointer;
            margin-top: -6px; 
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 4px;
            cursor: pointer; background: #cbd5e1;
            border-radius: 2px;
        }
    </style>
</head>
<body class="bg-gray-50 h-screen flex flex-col md:flex-row p-4 gap-4 overflow-hidden select-none text-gray-800">

    <!-- SIDEBAR CONTROL -->
    <div class="w-full md:w-1/3 bg-white rounded-xl shadow-lg flex flex-col h-full overflow-hidden">
        
        <!-- Tabs Header -->
        <div class="flex border-b shrink-0">
            <button onclick="switchTab('simulation')" id="tab-simulation" class="tab-btn active flex-1 py-4 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500 hover:bg-gray-50">
                <i data-lucide="rotate-ccw" class="w-5 h-5"></i> Mô Phỏng
            </button>
            <button onclick="switchTab('drawing')" id="tab-drawing" class="tab-btn flex-1 py-4 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500 hover:bg-gray-50">
                <i data-lucide="pen-tool" class="w-5 h-5"></i> Phòng Tranh
            </button>
            <button onclick="switchTab('game')" id="tab-game" class="tab-btn flex-1 py-4 text-sm font-bold flex flex-col items-center gap-1 transition-colors text-gray-500 hover:bg-gray-50">
                <i data-lucide="grid-3x3" class="w-5 h-5"></i> Thử Thách
            </button>
        </div>

        <!-- Content Area -->
        <div class="p-6 flex-1 overflow-y-auto relative">
            
            <!-- SECTION: SIMULATION -->
            <div id="content-simulation" class="space-y-6">
                <p class="text-gray-500 text-sm">Chọn hình và xoay 180° để tìm tâm đối xứng.</p>
                
                <div class="grid grid-cols-2 gap-2" id="shape-buttons">
                    <!-- Buttons generated by JS -->
                </div>

                <div class="bg-gray-50 p-4 rounded-lg border border-gray-200">
                    <label class="text-xs font-semibold text-gray-500 uppercase mb-2 block">Góc quay</label>
                    <div class="flex items-center gap-4 mb-2">
                        <button onclick="togglePlay()" id="btn-play" class="p-2 rounded-full text-white shadow bg-green-600 hover:bg-green-700 transition-colors">
                            <i data-lucide="play" class="w-5 h-5"></i>
                        </button>
                        <div class="flex-1">
                            <input type="range" id="rotation-slider" min="0" max="180" value="0" class="w-full">
                        </div>
                    </div>
                    <div class="flex justify-between text-xs font-bold text-gray-500">
                        <span>0°</span>
                        <span id="rotation-display" class="text-blue-600 text-lg">0°</span>
                        <span>180°</span>
                    </div>
                </div>

                <div class="flex items-center gap-2">
                    <input type="checkbox" id="chk-show-lines" checked class="w-4 h-4 text-blue-600 rounded">
                    <label for="chk-show-lines" class="text-sm cursor-pointer">Hiện đường nối tâm (nét đứt)</label>
                </div>
                
                <button onclick="resetSimulation()" class="w-full py-2 bg-gray-200 hover:bg-gray-300 rounded-lg text-sm font-medium flex justify-center items-center gap-2">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i> Đặt lại
                </button>
            </div>

            <!-- SECTION: DRAWING -->
            <div id="content-drawing" class="space-y-6 hidden">
                <div class="bg-blue-50 p-4 rounded-lg text-sm text-blue-800 border border-blue-200">
                    <h4 class="font-bold flex items-center gap-2 mb-1"><i data-lucide="info" class="w-4 h-4"></i> Hướng dẫn:</h4>
                    <p>Vẽ bất kỳ nét nào bên trái, máy sẽ tự động vẽ nét đối xứng qua tâm O (nét đứt).</p>
                </div>

                <div class="space-y-2">
                    <label class="text-sm font-semibold">Màu bút:</label>
                    <div class="flex gap-2" id="color-palette">
                        <!-- Colors generated by JS -->
                    </div>
                </div>

                <button onclick="clearDrawing()" class="w-full py-2 bg-gray-200 hover:bg-gray-300 rounded-lg font-medium flex justify-center items-center gap-2">
                    <i data-lucide="eraser" class="w-4 h-4"></i> Xóa bảng
                </button>
            </div>

            <!-- SECTION: GAME -->
            <div id="content-game" class="space-y-6 hidden">
                <div class="flex justify-between items-center">
                    <h3 class="font-bold text-lg text-gray-700">Level <span id="level-display">1</span></h3>
                    <div class="flex gap-1">
                        <button onclick="changeLevel(-1)" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300 text-sm">-</button>
                        <button onclick="changeLevel(1)" class="px-2 py-1 bg-gray-200 rounded hover:bg-gray-300 text-sm">+</button>
                    </div>
                </div>

                <div class="bg-green-50 p-4 rounded-lg text-green-900 border border-green-200 text-sm">
                    <p><strong>Nhiệm vụ:</strong> Hãy tô màu vào các ô trống sao cho cả hình nhận chấm đỏ làm tâm đối xứng.</p>
                </div>

                <div id="game-message" class="hidden bg-yellow-100 p-4 rounded-lg border border-yellow-300 text-center">
                    <div class="flex justify-center mb-2"><i data-lucide="trophy" class="w-10 h-10 text-yellow-600"></i></div>
                    <p class="font-bold text-yellow-800">Xuất sắc! Hoàn thành.</p>
                    <button onclick="initGame()" class="mt-2 px-4 py-1 bg-yellow-500 text-white rounded-full hover:bg-yellow-600 text-sm">Chơi tiếp</button>
                </div>
                
                <div id="game-playing-msg" class="bg-gray-100 p-3 rounded text-center text-sm text-gray-500">
                    Trạng thái: Đang chơi...
                </div>

                <button onclick="initGame()" class="w-full py-2 border border-gray-300 hover:bg-gray-50 rounded-lg font-medium flex justify-center items-center gap-2 text-sm">
                    <i data-lucide="refresh-cw" class="w-4 h-4"></i> Tạo màn mới
                </button>
            </div>
        </div>
    </div>

    <!-- CANVAS AREA -->
    <div class="flex-1 bg-white rounded-xl shadow-lg relative overflow-hidden flex items-center justify-center border-2 border-gray-100 touch-none">
        
        <!-- Background Grid (Hidden in Game Mode) -->
        <div id="bg-grid" class="absolute inset-0 opacity-10 pointer-events-none bg-grid-pattern"></div>
        
        <!-- Simulation & Drawing SVG -->
        <svg id="main-svg" width="500" height="500" viewBox="0 0 500 500" class="max-w-full max-h-full cursor-crosshair">
            <!-- Content will be rendered here by JS -->
        </svg>

        <!-- Mode Indicator -->
        <div class="absolute bottom-2 right-2 text-xs text-gray-400 bg-white/90 px-2 rounded pointer-events-none">
            Mode: <span id="mode-name">Mô Phỏng</span>
        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const CANVAS_SIZE = 500;
        const GRID_SIZE = 8;
        const CELL_SIZE = 40;
        const GAME_OFFSET_X = (CANVAS_SIZE - GRID_SIZE * CELL_SIZE) / 2;
        const GAME_OFFSET_Y = (CANVAS_SIZE - GRID_SIZE * CELL_SIZE) / 2;

        const shapes = {
            parallelogram: {
                name: "Hình bình hành",
                type: 'polygon', hasSymmetry: true,
                getPoints: (cx, cy) => [ {x:cx-80, y:cy-60}, {x:cx+40, y:cy-60}, {x:cx+80, y:cy+60}, {x:cx-40, y:cy+60} ]
            },
            rectangle: {
                name: "Hình chữ nhật",
                type: 'polygon', hasSymmetry: true,
                getPoints: (cx, cy) => [ {x:cx-80, y:cy-50}, {x:cx+80, y:cy-50}, {x:cx+80, y:cy+50}, {x:cx-80, y:cy+50} ]
            },
            triangle: {
                name: "Tam giác đều",
                type: 'polygon', hasSymmetry: false,
                getPoints: (cx, cy) => [ {x:cx, y:cy-70}, {x:cx+60.6, y:cy+35}, {x:cx-60.6, y:cy+35} ]
            },
            letterS: {
                name: "Chữ S",
                type: 'path', hasSymmetry: true,
                pathD: "M -30 -50 C -90 -50 -90 -10 -30 0 S 30 50 -30 50 S -90 10 -30 0"
            }
        };

        const colors = ['#3B82F6', '#EF4444', '#10B981', '#F59E0B', '#8B5CF6'];

        // --- STATE ---
        let state = {
            tab: 'simulation', // simulation, drawing, game
            center: { x: 250, y: 250 },
            
            // Simulation
            shapeType: 'parallelogram',
            rotation: 0,
            isPlaying: false,
            showLines: true,

            // Drawing
            drawPaths: [], // [{points: [], color: ''}]
            currentPath: [],
            drawingColor: '#3B82F6',
            isDrawing: false,

            // Game
            level: 1,
            grid: [], // 2D array
            gameStatus: 'playing' // playing, won
        };

        let isDraggingCenter = false;
        let animationId = null;

        // --- DOM ELEMENTS ---
        const svgEl = document.getElementById('main-svg');
        const sliderEl = document.getElementById('rotation-slider');
        const rotationDisplayEl = document.getElementById('rotation-display');
        const btnPlayEl = document.getElementById('btn-play');
        const bgGridEl = document.getElementById('bg-grid');

        // --- INITIALIZATION ---
        function init() {
            lucide.createIcons();
            renderShapeButtons();
            renderColorPalette();
            initGame(); // Prepare game data
            renderCanvas();

            // Slider Event
            sliderEl.addEventListener('input', (e) => {
                state.rotation = parseInt(e.target.value);
                state.isPlaying = false;
                updateUI();
                renderCanvas();
            });

            // SVG Events
            svgEl.addEventListener('mousedown', handlePointerDown);
            svgEl.addEventListener('mousemove', handlePointerMove);
            svgEl.addEventListener('mouseup', handlePointerUp);
            svgEl.addEventListener('mouseleave', handlePointerUp);
            
            svgEl.addEventListener('touchstart', (e) => handlePointerDown(e.touches[0]));
            svgEl.addEventListener('touchmove', (e) => { e.preventDefault(); handlePointerMove(e.touches[0]); });
            svgEl.addEventListener('touchend', handlePointerUp);

            document.getElementById('chk-show-lines').addEventListener('change', (e) => {
                state.showLines = e.target.checked;
                renderCanvas();
            });
        }

        // --- TABS LOGIC ---
        window.switchTab = function(tabName) {
            state.tab = tabName;
            state.isPlaying = false;
            state.rotation = 0;
            
            // Update UI Tabs
            document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`tab-${tabName}`).classList.add('active');

            // Show/Hide Content Areas
            ['simulation', 'drawing', 'game'].forEach(t => {
                const el = document.getElementById(`content-${t}`);
                if (t === tabName) el.classList.remove('hidden');
                else el.classList.add('hidden');
            });

            // Grid Visibility Logic (Fix for distracting grid)
            if (tabName === 'game') {
                bgGridEl.style.display = 'none';
            } else {
                bgGridEl.style.display = 'block';
                // Reset Center for other modes
                state.center = {x: 250, y: 250}; 
            }

            document.getElementById('mode-name').innerText = 
                tabName === 'simulation' ? 'Mô Phỏng' : (tabName === 'drawing' ? 'Phòng Tranh' : 'Trò Chơi');

            renderCanvas();
            updateUI();
        };

        // --- SIMULATION LOGIC ---
        function renderShapeButtons() {
            const container = document.getElementById('shape-buttons');
            container.innerHTML = '';
            for (const [key, shape] of Object.entries(shapes)) {
                const btn = document.createElement('button');
                btn.className = `shape-btn p-2 rounded-lg text-sm border border-gray-200 hover:bg-gray-50 transition-colors ${state.shapeType === key ? 'active' : ''}`;
                btn.innerText = shape.name;
                btn.onclick = () => {
                    state.shapeType = key;
                    state.rotation = 0;
                    state.isPlaying = false;
                    renderShapeButtons(); // Re-render to update active class
                    updateUI();
                    renderCanvas();
                };
                container.appendChild(btn);
            }
        }

        window.togglePlay = function() {
            state.isPlaying = !state.isPlaying;
            updateUI();
            if (state.isPlaying) animate();
            else cancelAnimationFrame(animationId);
        };

        window.resetSimulation = function() {
            state.center = {x: 250, y: 250};
            state.rotation = 0;
            state.isPlaying = false;
            updateUI();
            renderCanvas();
        };

        function animate() {
            if (!state.isPlaying) return;
            state.rotation += 1;
            if (state.rotation >= 180) {
                state.rotation = 180;
                state.isPlaying = false;
            }
            updateUI();
            renderCanvas();
            if (state.isPlaying) {
                animationId = requestAnimationFrame(animate);
            }
        }

        function updateUI() {
            sliderEl.value = state.rotation;
            rotationDisplayEl.innerText = state.rotation + "°";
            
            // Toggle Play/Pause Icon
            btnPlayEl.innerHTML = state.isPlaying 
                ? '<i data-lucide="pause" class="w-5 h-5"></i>' 
                : '<i data-lucide="play" class="w-5 h-5"></i>';
            lucide.createIcons();
            
            // Game UI
            document.getElementById('level-display').innerText = state.level;
            const gameMsg = document.getElementById('game-message');
            const playMsg = document.getElementById('game-playing-msg');
            
            if (state.gameStatus === 'won') {
                gameMsg.classList.remove('hidden');
                playMsg.classList.add('hidden');
            } else {
                gameMsg.classList.add('hidden');
                playMsg.classList.remove('hidden');
            }
        }

        // --- DRAWING LOGIC ---
        function renderColorPalette() {
            const container = document.getElementById('color-palette');
            colors.forEach(c => {
                const btn = document.createElement('button');
                btn.className = 'w-8 h-8 rounded-full border-2 transition-transform';
                btn.style.backgroundColor = c;
                btn.onclick = () => {
                    state.drawingColor = c;
                    renderColorPalette(); // refresh active state visual if needed
                };
                // Highlight active color logic could be added here
                container.appendChild(btn);
            });
        }

        window.clearDrawing = function() {
            state.drawPaths = [];
            state.currentPath = [];
            renderCanvas();
        };

        // --- GAME LOGIC ---
        window.changeLevel = function(delta) {
            let newLevel = state.level + delta;
            if (newLevel < 1) newLevel = 1;
            if (newLevel > 10) newLevel = 10;
            state.level = newLevel;
            initGame();
            updateUI();
        };

        window.initGame = function() {
            // Initialize Grid
            let grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(0));
            const numPairs = 3 + state.level; 
            let count = 0;

            while (count < numPairs) {
                const r = Math.floor(Math.random() * GRID_SIZE);
                const c = Math.floor(Math.random() * GRID_SIZE);
                const symR = GRID_SIZE - 1 - r;
                const symC = GRID_SIZE - 1 - c;

                if (grid[r][c] === 0 && grid[symR][symC] === 0) {
                    grid[r][c] = 1; // Machine set
                    count++;
                }
            }
            state.grid = grid;
            state.gameStatus = 'playing';
            updateUI();
            renderCanvas();
        };

        function handleGameClick(x, y) {
            if (state.gameStatus === 'won') return;
            
            // Check bounds
            if (x < GAME_OFFSET_X || x > GAME_OFFSET_X + GRID_SIZE * CELL_SIZE ||
                y < GAME_OFFSET_Y || y > GAME_OFFSET_Y + GRID_SIZE * CELL_SIZE) return;

            const c = Math.floor((x - GAME_OFFSET_X) / CELL_SIZE);
            const r = Math.floor((y - GAME_OFFSET_Y) / CELL_SIZE);

            if (state.grid[r][c] === 1) return; // Cannot toggle question cells

            // Toggle 0 <-> 2
            state.grid[r][c] = state.grid[r][c] === 2 ? 0 : 2;
            
            checkWin();
            renderCanvas();
        }

        function checkWin() {
            let isFullSymmetry = true;
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const val = state.grid[r][c];
                    const symVal = state.grid[GRID_SIZE-1-r][GRID_SIZE-1-c];
                    if (val !== 0 && symVal === 0) isFullSymmetry = false;
                }
            }
            if (isFullSymmetry) {
                state.gameStatus = 'won';
                updateUI();
            }
        }

        // --- MAIN RENDERER (SVG) ---
        function renderCanvas() {
            // Clear SVG
            svgEl.innerHTML = ''; 

            if (state.tab === 'simulation') renderSimulationMode();
            else if (state.tab === 'drawing') renderDrawingMode();
            else if (state.tab === 'game') renderGameMode();

            // Draw Center O (Except in Game Mode, where it's static)
            if (state.tab !== 'game') {
                const g = createSVGElement('g', {
                    transform: `translate(${state.center.x}, ${state.center.y})`,
                    class: 'cursor-move',
                    style: 'cursor: move'
                });
                g.appendChild(createSVGElement('circle', { r: 15, fill: 'transparent' })); // Hitbox
                g.appendChild(createSVGElement('circle', { r: 6, fill: '#ef4444', stroke: 'white', 'stroke-width': 2 }));
                const text = createSVGElement('text', { x: 10, y: -10, fill: '#ef4444', 'font-weight': 'bold', 'font-size': 14 });
                text.textContent = 'O';
                g.appendChild(text);
                svgEl.appendChild(g);
            }
        }

        function createSVGElement(tag, attrs) {
            const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
            for (const [key, value] of Object.entries(attrs)) {
                el.setAttribute(key, value);
            }
            return el;
        }

        function renderSimulationMode() {
            const shape = shapes[state.shapeType];
            
            // 1. Static Ghost Shape
            if (shape.type === 'polygon') {
                const pts = shape.getPoints(250, 250).map(p => `${p.x},${p.y}`).join(' ');
                svgEl.appendChild(createSVGElement('polygon', {
                    points: pts, fill: 'rgba(156, 163, 175, 0.2)', stroke: '#9CA3AF', 'stroke-width': 2, 'stroke-dasharray': '5,5'
                }));
            } else if (shape.type === 'path') {
                const g = createSVGElement('g', { transform: 'translate(250, 250)' });
                g.appendChild(createSVGElement('path', {
                    d: shape.pathD, stroke: '#9CA3AF', 'stroke-width': 8, fill: 'none', opacity: 0.2
                }));
                svgEl.appendChild(g);
            }

            // 2. Rotating Shape
            const rotG = createSVGElement('g', {
                transform: `rotate(${state.rotation}, ${state.center.x}, ${state.center.y})`
            });

            if (shape.type === 'polygon') {
                const pts = shape.getPoints(250, 250).map(p => `${p.x},${p.y}`).join(' ');
                rotG.appendChild(createSVGElement('polygon', {
                    points: pts, fill: 'rgba(59, 130, 246, 0.3)', stroke: '#3B82F6', 'stroke-width': 3
                }));
            } else if (shape.type === 'path') {
                const gInner = createSVGElement('g', { transform: 'translate(250, 250)' });
                gInner.appendChild(createSVGElement('path', {
                    d: shape.pathD, stroke: '#3B82F6', 'stroke-width': 8, fill: 'none', 'stroke-linecap': 'round'
                }));
                rotG.appendChild(gInner);
            }
            svgEl.appendChild(rotG);

            // 3. Connecting Lines
            if (state.showLines && shape.type === 'polygon') {
                shape.getPoints(250, 250).forEach(p => {
                    svgEl.appendChild(createSVGElement('line', {
                        x1: p.x, y1: p.y, x2: state.center.x, y2: state.center.y,
                        stroke: '#ef4444', 'stroke-width': 1, 'stroke-dasharray': '4,4', opacity: 0.3
                    }));
                });
            }
        }

        function renderDrawingMode() {
            // Helper to draw a polyline
            const drawPoly = (points, color, dashed = false) => {
                const ptsStr = points.map(p => `${p.x},${p.y}`).join(' ');
                svgEl.appendChild(createSVGElement('polyline', {
                    points: ptsStr, fill: 'none', stroke: color, 'stroke-width': 3,
                    'stroke-linecap': 'round', 'stroke-linejoin': 'round',
                    'stroke-dasharray': dashed ? '5,5' : 'none', opacity: dashed ? 0.6 : 1
                }));
            };

            // Existing paths
            state.drawPaths.forEach(path => {
                drawPoly(path.points, path.color);
                // Symmetric
                const symPoints = path.points.map(p => ({ x: 2*state.center.x - p.x, y: 2*state.center.y - p.y }));
                drawPoly(symPoints, path.color, true);
            });

            // Current drawing
            if (state.currentPath.length > 0) {
                drawPoly(state.currentPath, state.drawingColor);
                const symPoints = state.currentPath.map(p => ({ x: 2*state.center.x - p.x, y: 2*state.center.y - p.y }));
                drawPoly(symPoints, state.drawingColor, true);
            }
        }

        function renderGameMode() {
            // Draw grid cells
            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const x = GAME_OFFSET_X + c * CELL_SIZE;
                    const y = GAME_OFFSET_Y + r * CELL_SIZE;
                    
                    let fill = 'white';
                    if (state.grid[r][c] === 1) fill = '#60A5FA'; // Machine
                    if (state.grid[r][c] === 2) fill = '#34D399'; // User
                    if (state.gameStatus === 'won' && state.grid[r][c] !== 0) fill = '#FBBF24';

                    svgEl.appendChild(createSVGElement('rect', {
                        x: x, y: y, width: CELL_SIZE, height: CELL_SIZE,
                        fill: fill, stroke: '#E5E7EB', 'stroke-width': 1
                    }));
                }
            }
            // Border
            svgEl.appendChild(createSVGElement('rect', {
                x: GAME_OFFSET_X, y: GAME_OFFSET_Y, 
                width: GRID_SIZE * CELL_SIZE, height: GRID_SIZE * CELL_SIZE,
                fill: 'none', stroke: '#374151', 'stroke-width': 2
            }));
            
            // Center Dot (Fixed)
            const cx = GAME_OFFSET_X + (GRID_SIZE * CELL_SIZE) / 2;
            const cy = GAME_OFFSET_Y + (GRID_SIZE * CELL_SIZE) / 2;
            svgEl.appendChild(createSVGElement('circle', { cx: cx, cy: cy, r: 6, fill: '#ef4444', stroke: 'white', 'stroke-width': 2 }));
        }

        // --- POINTER HANDLER ---
        function getMousePos(e) {
            const rect = svgEl.getBoundingClientRect();
            // Check if it's a touch event or mouse event
            const clientX = e.clientX !== undefined ? e.clientX : (e.touches ? e.touches[0].clientX : 0);
            const clientY = e.clientY !== undefined ? e.clientY : (e.touches ? e.touches[0].clientY : 0);
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handlePointerDown(e) {
            const pos = getMousePos(e);

            if (state.tab === 'game') {
                handleGameClick(pos.x, pos.y);
                return;
            }

            // Check center drag
            if (Math.abs(pos.x - state.center.x) < 20 && Math.abs(pos.y - state.center.y) < 20) {
                isDraggingCenter = true;
                return;
            }

            if (state.tab === 'drawing') {
                state.isDrawing = true;
                state.currentPath = [pos];
            }
        }

        function handlePointerMove(e) {
            const pos = getMousePos(e);

            if (isDraggingCenter) {
                state.center = pos;
                renderCanvas();
                return;
            }

            if (state.tab === 'drawing' && state.isDrawing) {
                state.currentPath.push(pos);
                renderCanvas(); // Redraw for smooth line
            }
        }

        function handlePointerUp() {
            isDraggingCenter = false;
            if (state.tab === 'drawing' && state.isDrawing) {
                state.isDrawing = false;
                if (state.currentPath.length > 0) {
                    state.drawPaths.push({ points: state.currentPath, color: state.drawingColor });
                }
                state.currentPath = [];
                renderCanvas();
            }
        }

        // Start
        init();

    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mô phỏng 3D: Bài toán Vùng Mất Sóng</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: 'Inter', sans-serif; background-color: #f0f2f5; }
        #container { width: 100%; height: 100vh; display: flex; flex-direction: column; }
        #simulation-container { flex-grow: 1; position: relative; }
        canvas { display: block; }
        #info-panel {
            position: absolute;
            top: 1rem;
            left: 1rem;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 1rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 350px;
            backdrop-filter: blur(5px);
        }
        #solution-panel {
            padding: 2rem;
            background-color: white;
            overflow-y: auto; /* Add scroll for smaller heights */
        }
        .control-panel {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
         .control-panel button {
            background-color: #3b82f6;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .control-panel button:hover {
            background-color: #2563eb;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body>

<div id="container">
    <div id="simulation-container">
        <div id="info-panel">
            <h2 class="text-xl font-bold mb-2 text-gray-800">Bài toán Vùng Mất Sóng</h2>
            <p class="text-sm text-gray-600">Mô phỏng cho thấy vùng không gian bị bức tường <span class="font-semibold text-green-600">ABCD</span> che khuất, tạo ra một "vùng tối" (hình chóp màu xám) từ trạm phát sóng <span class="font-semibold text-blue-600">S</span>. Người di chuyển theo đường <span class="font-semibold text-red-600">màu đỏ</span> từ điểm P₀. Điểm <span class="font-semibold text-purple-600">M</span> là vị trí người bắt đầu đi vào vùng mất sóng.</p>
             <p class="text-sm text-gray-600 mt-2">Dùng chuột để xoay (trái), di chuyển (phải) và phóng to/thu nhỏ (cuộn) mô hình.</p>
        </div>
         <div class="control-panel">
            <button id="reset-animation-btn">Chạy lại</button>
        </div>
    </div>
    <div id="solution-panel" class="bg-white">
        <div class="max-w-4xl mx-auto">
            <h2 class="text-2xl font-bold mb-4 text-gray-800">Phân tích và Lời giải chi tiết</h2>
            
            <div class="space-y-6">
                <div>
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">1. Xác định tọa độ các đỉnh của bức tường</h3>
                    <p class="text-gray-600">Bức tường ABCD vuông góc với mặt đất (mặt phẳng Oxy). Ta có tọa độ hai điểm chân tường là A(2; 1; 0) và B(0; 2; 0). Vì chiều cao là 3m, ta có tọa độ các đỉnh trên là D(2; 1; 3) và C(0; 2; 3).</p>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">2. Tìm "vùng tối" trên mặt đất</h3>
                    <p class="text-gray-600">Người đi trên mặt đất (z=0) sẽ mất sóng khi đường thẳng nối từ người đó đến trạm phát sóng S(3; 3; 6) bị bức tường ABCD chắn. Do trạm S cao hơn tường, nên "vùng tối" trên mặt đất sẽ được tạo ra bởi các đường thẳng đi qua S và mép trên của tường (đoạn thẳng CD).</p>
                    <ul class="list-disc list-inside text-gray-600 mt-2 pl-4">
                        <li>Đường thẳng đi qua S(3; 3; 6) và C(0; 2; 3) cắt mặt phẳng z=0 tại điểm M<sub>C</sub>(-3; 1; 0).</li>
                        <li>Đường thẳng đi qua S(3; 3; 6) và D(2; 1; 3) cắt mặt phẳng z=0 tại điểm M<sub>D</sub>(1; -1; 0).</li>
                    </ul>
                    <p class="text-gray-600 mt-2">Vậy, ranh giới của vùng mất sóng trên mặt đất là đoạn thẳng M<sub>C</sub>M<sub>D</sub>.</p>
                </div>
                
                <div>
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">3. Tìm giao điểm M</h3>
                    <p class="text-gray-600">Người di chuyển từ P₀(-4; -4; 0) về gốc tọa độ O(0; 0; 0), do đó đường đi của người nằm trên đường thẳng <span class="font-mono">y = x</span>. Ta cần tìm giao điểm M của đường thẳng này với đoạn M<sub>C</sub>M<sub>D</sub>.</p>
                    <p class="text-gray-600 mt-2">Phương trình đường thẳng đi qua M<sub>C</sub>(-3; 1) và M<sub>D</sub>(1; -1) là <span class="font-mono">y = -0.5x - 0.5</span>.</p>
                    <p class="text-gray-600 mt-2">Giải hệ phương trình, ta có: <span class="font-mono">x = -0.5x - 0.5</span>  => <span class="font-mono">1.5x = -0.5</span> => <span class="font-mono">x = -1/3</span>. Vậy M có tọa độ là (-1/3; -1/3; 0).</p>
                </div>

                <div>
                    <h3 class="text-lg font-semibold mb-2 text-gray-700">4. Tính thời gian di chuyển</h3>
                    <p class="text-gray-600">Người đó mất sóng khi đi từ P₀(-4; -4; 0) đến M(-1/3; -1/3; 0). Quãng đường đi được là:</p>
                    <p class="text-center font-mono text-lg my-3 text-indigo-600">d = &radic;[(-1/3 - (-4))² + (-1/3 - (-4))²] = (11/3)&radic;2 m</p>
                    <p class="text-gray-600">Với vận tốc 1 m/s, thời gian di chuyển bằng quãng đường đi được:</p>
                    <p class="text-center font-mono text-lg my-3 text-indigo-600">t = d / v = [(11&radic;2)/3] / 1 &approx; 5.185 s</p>
                </div>

                <div class="bg-blue-50 p-4 rounded-lg">
                    <h3 class="text-xl font-bold text-center text-blue-800">Kết quả cuối cùng</h3>
                    <p class="text-center text-2xl font-bold mt-2 text-blue-700">Làm tròn đến hàng phần mười, thời gian cần tìm là 5.2 giây.</p>
                </div>
            </div>
        </div>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { FontLoader } from 'three/addons/loaders/FontLoader.js';
    import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

    let scene, camera, renderer, controls;
    let person, font;
    
    // Key points from the problem
    const A = new THREE.Vector3(2, 1, 0);
    const B = new THREE.Vector3(0, 2, 0);
    const C = new THREE.Vector3(0, 2, 3);
    const D = new THREE.Vector3(2, 1, 3);
    const S = new THREE.Vector3(3, 3, 6);
    const P0 = new THREE.Vector3(-4, -4, 0);
    const O = new THREE.Vector3(0, 0, 0);
    
    // Calculated points
    const Mc = new THREE.Vector3(-3, 1, 0);
    const Md = new THREE.Vector3(1, -1, 0);
    const M = new THREE.Vector3(-1/3, -1/3, 0);

    let startTime;
    const animationDuration = 8000; // 8 seconds for full path animation

    function init() {
        const container = document.getElementById('simulation-container');

        // Scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f2f5);

        // Camera
        camera = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(-6, -8, 7);
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Controls
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.target.set(0, 0, 1);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);

        // Ground Grid
        const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xdddddd);
        gridHelper.rotation.x = Math.PI / 2; // Xoay lưới để nằm trên mặt phẳng Oxy (mặt đất)
        gridHelper.position.z = -0.01; // Đặt thấp hơn mặt đất một chút để tránh xung đột render
        scene.add(gridHelper);
        
        // Axes
        const axesHelper = new THREE.AxesHelper(10);
        scene.add(axesHelper);

        // Load font and create objects
        const loader = new FontLoader();
        loader.load('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', function (loadedFont) {
            font = loadedFont;
            createObjects();
        });

        document.getElementById('reset-animation-btn').addEventListener('click', resetAnimation);
        window.addEventListener('resize', onWindowResize, false);
        
        resetAnimation();
        animate();
    }

    function createObjects() {
        // Wall
        const wallGeometry = new THREE.BufferGeometry();
        const vertices = new Float32Array([
            ...A.toArray(), ...B.toArray(), ...D.toArray(),
            ...B.toArray(), ...C.toArray(), ...D.toArray()
        ]);
        wallGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        wallGeometry.computeVertexNormals();
        const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x22c55e, opacity: 0.7, transparent: true, side: THREE.DoubleSide });
        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
        scene.add(wall);

        // Key Points Markers
        createMarker(S, 0x3b82f6, 'S'); // Source
        createMarker(A, 0x16a34a, 'A');
        createMarker(B, 0x16a34a, 'B');
        createMarker(C, 0x16a34a, 'C');
        createMarker(D, 0x16a34a, 'D');
        createMarker(P0, 0xef4444, 'P₀'); // Start point
        createMarker(O, 0x6b7280, 'O');
        createMarker(M, 0x8b5cf6, 'M'); // Intersection point

        // Person's Path
        const pathMaterial = new THREE.LineBasicMaterial({ color: 0xef4444, linewidth: 2 });
        const pathGeometry = new THREE.BufferGeometry().setFromPoints([P0, O]);
        const pathLine = new THREE.Line(pathGeometry, pathMaterial);
        scene.add(pathLine);

        // Shadow visualization
        const shadowMaterial = new THREE.LineDashedMaterial({ color: 0x6b7280, dashSize: 0.2, gapSize: 0.1 });
        const shadowVolumeMaterial = new THREE.MeshBasicMaterial({ color: 0x71717a, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
        
        // Shadow on ground
        const groundShadowGeometry = new THREE.BufferGeometry().setFromPoints([Mc, Md]);
        const groundShadowLine = new THREE.Line(groundShadowGeometry, new THREE.LineBasicMaterial({ color: 0x8b5cf6, linewidth: 3 }));
        groundShadowLine.computeLineDistances();
        scene.add(groundShadowLine);
        
        // Shadow lines from S
        scene.add(createLine(S, C, shadowMaterial));
        scene.add(createLine(S, D, shadowMaterial));
        scene.add(createLine(S, Mc, shadowMaterial));
        scene.add(createLine(S, Md, shadowMaterial));

        // Shadow volume
        const shadowVolumeGeometry = new THREE.BufferGeometry();
        const shadowVertices = new Float32Array([
            ...S.toArray(), ...C.toArray(), ...D.toArray(),
            ...C.toArray(), ...Mc.toArray(), ...Md.toArray(),
            ...D.toArray(), ...C.toArray(), ...Md.toArray(),
            ...S.toArray(), ...D.toArray(), ...Md.toArray(),
            ...S.toArray(), ...Mc.toArray(), ...C.toArray()
        ]);
        shadowVolumeGeometry.setAttribute('position', new THREE.BufferAttribute(shadowVertices, 3));
        const shadowVolume = new THREE.Mesh(shadowVolumeGeometry, shadowVolumeMaterial);
        scene.add(shadowVolume);

        // Person
        const personGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const personMaterial = new THREE.MeshBasicMaterial({ color: 0xdc2626 });
        person = new THREE.Mesh(personGeometry, personMaterial);
        person.position.copy(P0);
        scene.add(person);
    }

    function createMarker(position, color, label) {
        const material = new THREE.MeshBasicMaterial({ color: color });
        const geometry = new THREE.SphereGeometry(0.1, 16, 16);
        const marker = new THREE.Mesh(geometry, material);
        marker.position.copy(position);
        scene.add(marker);
        
        if (font && label) {
            const textGeometry = new TextGeometry(label, {
                font: font,
                size: 0.2,
                height: 0.02,
            });
            const textMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const textMesh = new THREE.Mesh(textGeometry, textMaterial);
            textMesh.position.copy(position).add(new THREE.Vector3(0.1, 0.1, 0.1));
            scene.add(textMesh);
        }
    }
    
    function createLine(start, end, material){
        const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
        const line = new THREE.Line(geometry, material);
        line.computeLineDistances();
        return line;
    }

    function resetAnimation() {
        startTime = Date.now();
        if(person) person.position.copy(P0);
    }
    
    function onWindowResize() {
        const container = document.getElementById('simulation-container');
        if (!container) return;
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    }
    
    function animate() {
        requestAnimationFrame(animate);

        const elapsedTime = Date.now() - startTime;
        let progress = elapsedTime / animationDuration;
        if (progress > 1) progress = 1;
        
        if(person){
             // Animate person from P0 to O
            person.position.lerpVectors(P0, O, progress);
        }

        controls.update();
        renderer.render(scene, camera);
    }

    init();
</script>

</body>
</html>


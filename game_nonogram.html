<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nonogram - CLB To√°n H·ªçc</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&family=Orbitron:wght@500;700;900&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        body { font-family: 'Be Vietnam Pro', sans-serif; background-color: #0f172a; color: #e2e8f0; user-select: none; touch-action: none; overflow: hidden; }
        .font-tech { font-family: 'Orbitron', sans-serif; }
        
        /* --- Grid Styles --- */
        .nonogram-cell {
            transition: background-color 0.1s;
            position: relative;
        }
        
        .cell-filled {
            background-color: #22d3ee !important;
            border-color: #06b6d4 !important;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }
        
        .cell-crossed {
            background-color: #1e293b !important;
        }
        .cell-crossed::after {
            content: "‚úñ"; font-size: 70%; font-weight: bold; color: #64748b;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        .cell-highlight-guide { background-color: rgba(56, 189, 248, 0.1) !important; }
        .cell-filled.cell-highlight-guide { background-color: #38bdf8 !important; }

        /* --- Hint Styles --- */
        .hint-num {
            font-size: 0.75rem; color: #94a3b8; margin: 1px; transition: all 0.3s;
        }
        .hint-completed {
            color: #475569; text-decoration: line-through; opacity: 0.5;
        }
        
        /* --- Zoom & Pan --- */
        #game-board {
            transform-origin: 0 0;
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); /* Smooth centering animation */
        }
        #viewport {
            cursor: grab;
            overflow: hidden;
            position: relative;
            background-image: radial-gradient(#1e293b 1px, transparent 1px);
            background-size: 20px 20px;
        }
        #viewport.cursor-crosshair { cursor: crosshair; }
        #viewport.cursor-grabbing { cursor: grabbing; }

        /* --- UI Elements --- */
        .btn-tool:active { transform: scale(0.95); }
        .btn-active {
            background-color: #0891b2 !important; color: white !important;
            box-shadow: 0 0 10px rgba(8, 145, 178, 0.5);
            border-color: #22d3ee !important;
        }

        /* Modal & Toasts */
        .modal-overlay {
            background-color: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(4px);
        }
        
        @keyframes slideInUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .toast-anim { animation: slideInUp 0.3s ease-out; }

        @keyframes flashHint {
            0% { background-color: #facc15; box-shadow: 0 0 20px #facc15; z-index: 50; }
            100% { z-index: 0; }
        }
        .hint-anim { animation: flashHint 0.8s ease-out; }
    </style>
</head>
<body class="h-screen w-screen flex flex-col p-2 overflow-hidden">

    <!-- 1. Header Area -->
    <header class="flex justify-between items-center mb-2 px-1 shrink-0">
        <div class="flex items-center gap-3">
            <div>
                <h1 class="text-lg md:text-2xl font-bold font-tech text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-400">
                    NONOGRAM
                </h1>
                <p class="text-slate-500 text-[10px] md:text-xs">Logic Puzzle</p>
            </div>
            <!-- N√∫t H∆∞·ªõng D·∫´n M·ªõi: N·ªïi b·∫≠t h∆°n -->
            <button onclick="toggleRules()" class="bg-purple-600 hover:bg-purple-500 text-white px-3 py-1 rounded-full text-xs font-bold shadow-lg shadow-purple-500/30 flex items-center gap-1 transition-all animate-pulse">
                <i class="fa-solid fa-circle-question"></i> H∆∞·ªõng D·∫´n
            </button>
        </div>
        
        <select id="level-select" class="bg-slate-800 border border-slate-600 text-cyan-400 text-xs rounded-lg p-1.5 outline-none max-w-[140px] shadow-sm">
            <!-- JS will populate -->
        </select>
    </header>

    <!-- 2. Toolbar Area -->
    <div class="flex flex-wrap gap-2 mb-2 justify-center items-center shrink-0 bg-slate-900/80 p-2 rounded-xl border border-slate-700 shadow-lg z-10">
        
        <!-- Tools -->
        <div class="flex bg-slate-800 rounded-lg p-1 border border-slate-700">
            <button id="tool-draw" onclick="setTool('draw')" class="btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1">
                <i class="fa-solid fa-pen"></i> <span class="hidden sm:inline">V·∫Ω</span>
            </button>
            <button id="tool-pan" onclick="setTool('pan')" class="btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1 transition-colors">
                <i class="fa-solid fa-hand"></i> <span class="hidden sm:inline">K√©o</span>
            </button>
        </div>

        <!-- Draw Modes -->
        <div id="draw-modes" class="flex bg-slate-800 rounded-lg p-1 border border-slate-700 transition-opacity">
            <button id="mode-fill" onclick="setDrawMode('fill')" class="btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1">
                <i class="fa-solid fa-square"></i> T√¥
            </button>
            <button id="mode-cross" onclick="setDrawMode('cross')" class="btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1">
                <i class="fa-solid fa-xmark"></i> X√≥a
            </button>
        </div>

        <!-- Helpers -->
        <div class="flex gap-1">
            <button onclick="getLogicalHint()" class="btn-tool bg-yellow-600/20 hover:bg-yellow-600/40 text-yellow-500 border border-yellow-600/50 rounded-lg px-3 py-1.5 text-xs shadow-[0_0_10px_rgba(234,179,8,0.1)] transition-all" title="G·ª£i √Ω 1 n∆∞·ªõc ƒëi logic">
                <i class="fa-solid fa-lightbulb"></i> G·ª£i √Ω
            </button>
            <!-- N√∫t Gi·∫£i (Show Answer) ƒê√£ Kh√¥i Ph·ª•c -->
            <button onclick="showAnswer()" class="btn-tool bg-rose-900/40 hover:bg-rose-700/60 text-rose-400 border border-rose-800 rounded-lg px-3 py-1.5 text-xs transition-all" title="Hi·ªán to√†n b·ªô ƒë√°p √°n">
                <i class="fa-solid fa-key"></i> Gi·∫£i
            </button>
            <button onclick="centerBoard()" class="btn-tool bg-slate-700 hover:bg-slate-600 text-white rounded-lg px-3 py-1.5 text-xs" title="CƒÉn gi·ªØa">
                <i class="fa-solid fa-compress"></i>
            </button>
        </div>
    </div>

    <!-- 3. Game Viewport -->
    <div id="viewport" class="flex-1 rounded-xl border border-slate-700 shadow-inner relative w-full h-full">
        <div id="game-board-container" class="absolute top-0 left-0">
            <div id="game-board" class="inline-block p-10">
                <!-- Grid generated by JS -->
            </div>
        </div>

        <!-- Hint Toast Message -->
        <div id="hint-toast" class="hidden absolute bottom-4 left-1/2 -translate-x-1/2 bg-slate-800/95 text-white px-4 py-3 rounded-lg border border-yellow-500/50 shadow-2xl z-40 max-w-[90%] md:max-w-md text-sm toast-anim flex gap-3 items-start">
            <div class="text-yellow-400 text-lg mt-0.5"><i class="fa-solid fa-lightbulb"></i></div>
            <div>
                <h4 class="font-bold text-yellow-400 text-xs uppercase mb-1">G·ª£i √Ω Logic</h4>
                <p id="hint-text" class="text-slate-200 leading-snug">N·ªôi dung g·ª£i √Ω...</p>
            </div>
            <button onclick="document.getElementById('hint-toast').classList.add('hidden')" class="text-slate-500 hover:text-white"><i class="fa-solid fa-xmark"></i></button>
        </div>
    </div>

    <!-- 4. Rules Modal -->
    <div id="rules-modal" class="hidden fixed inset-0 z-50 modal-overlay flex items-center justify-center p-4">
        <div class="bg-slate-900 border border-slate-700 rounded-2xl max-w-md w-full shadow-2xl overflow-hidden animate-[fadeIn_0.2s]">
            <div class="bg-slate-800 p-4 border-b border-slate-700 flex justify-between items-center">
                <h3 class="font-bold text-white text-lg font-tech"><i class="fa-solid fa-book-open mr-2"></i>Lu·∫≠t Ch∆°i Nonogram</h3>
                <button onclick="toggleRules()" class="text-slate-400 hover:text-white"><i class="fa-solid fa-xmark text-xl"></i></button>
            </div>
            <div class="p-6 text-sm text-slate-300 space-y-4 max-h-[60vh] overflow-y-auto">
                <p><strong>M·ª•c ti√™u:</strong> T√¥ ƒëen c√°c √¥ vu√¥ng trong l∆∞·ªõi ƒë·ªÉ t·∫°o th√†nh m·ªôt b·ª©c tranh ·∫©n d·ª±a tr√™n c√°c con s·ªë g·ª£i √Ω.</p>
                
                <div class="bg-slate-800/50 p-3 rounded-lg border border-slate-700">
                    <p class="text-cyan-400 font-bold mb-1">üîç C√°ch ƒë·ªçc s·ªë:</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li>S·ªë ·ªü h√†ng/c·ªôt th·ªÉ hi·ªán <strong>ƒë·ªô d√†i c√°c ƒëo·∫°n li√™n ti·∫øp</strong> c·∫ßn t√¥ ƒëen.</li>
                        <li>V√≠ d·ª• h√†ng c√≥ s·ªë <strong>"3 2"</strong> nghƒ©a l√†: C√≥ m·ªôt ƒëo·∫°n <strong>3 √¥ ƒëen</strong>, sau ƒë√≥ l√† √≠t nh·∫•t <strong>1 √¥ tr·ªëng</strong>, r·ªìi ƒë·∫øn <strong>2 √¥ ƒëen</strong>.</li>
                    </ul>
                </div>

                <div class="bg-slate-800/50 p-3 rounded-lg border border-slate-700">
                    <p class="text-yellow-400 font-bold mb-1">üí° M·∫πo suy lu·∫≠n:</p>
                    <ul class="list-disc pl-5 space-y-1">
                        <li><strong>√î ch·∫Øc ch·∫Øn:</strong> N·∫øu s·ªë g·ª£i √Ω l·ªõn (v√≠ d·ª• 8 trong h√†ng 10 √¥), c√°c √¥ ·ªü gi·ªØa ch·∫Øc ch·∫Øn s·∫Ω ƒë∆∞·ª£c t√¥.</li>
                        <li><strong>ƒê√°nh d·∫•u X:</strong> D√πng chu·ªôt ph·∫£i ho·∫∑c ch·∫ø ƒë·ªô X√≥a ƒë·ªÉ ƒë√°nh d·∫•u c√°c √¥ ch·∫Øc ch·∫Øn l√† TR·ªêNG. ƒêi·ªÅu n√†y r·∫•t quan tr·ªçng!</li>
                    </ul>
                </div>
            </div>
            <div class="p-4 bg-slate-800/50 border-t border-slate-700 text-center">
                <button onclick="toggleRules()" class="bg-cyan-600 hover:bg-cyan-500 text-white px-6 py-2 rounded-lg font-bold transition-all">ƒê√£ Hi·ªÉu</button>
            </div>
        </div>
    </div>

    <!-- 5. Victory Overlay -->
    <div id="win-overlay" class="hidden fixed bottom-0 left-0 right-0 z-50 flex flex-col items-center justify-end pb-10 pointer-events-none">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-gradient-to-t from-slate-900 via-slate-900/90 to-transparent pointer-events-auto"></div>
        
        <!-- Content -->
        <div class="relative z-10 text-center p-6 w-full max-w-lg pointer-events-auto animate-[slideInUp_0.5s]">
            <div class="text-5xl text-yellow-400 mb-2 drop-shadow-[0_0_25px_rgba(250,204,21,0.6)] animate-bounce">
                <i class="fa-solid fa-trophy"></i>
            </div>
            <h2 class="text-3xl font-bold text-white font-tech mb-1">HO√ÄN TH√ÄNH!</h2>
            <p class="text-cyan-400 mb-6 text-lg font-semibold" id="level-name-display">H√¨nh b√≠ ·∫©n</p>
            
            <div class="flex flex-col gap-3">
                <div class="flex gap-3 justify-center">
                    <button onclick="nextLevel()" class="px-8 py-3 bg-gradient-to-r from-cyan-500 to-blue-600 hover:from-cyan-400 hover:to-blue-500 text-white font-bold rounded-xl shadow-lg shadow-cyan-500/30 transform transition-all hover:-translate-y-1">
                        M√†n Ti·∫øp Theo <i class="fa-solid fa-arrow-right ml-2"></i>
                    </button>
                </div>
                <button onclick="toggleWinOverlay(false)" class="text-slate-400 hover:text-white text-sm underline mt-2">
                    <i class="fa-regular fa-eye"></i> Xem l·∫°i h√¨nh v·∫Ω (·∫®n b·∫£ng n√†y)
                </button>
            </div>
        </div>
    </div>

    <!-- Floating "Show Win" button (visible when win overlay is hidden) -->
    <button id="show-win-btn" onclick="toggleWinOverlay(true)" class="hidden fixed bottom-4 right-4 z-40 bg-yellow-600 text-white px-4 py-2 rounded-full shadow-lg font-bold animate-pulse">
        <i class="fa-solid fa-trophy"></i> K·∫øt qu·∫£
    </button>

    <script>
        // --- DATA ---
        const levels = [
            { name: "Tr√°i Tim (5x5)", size: 5, grid: [[0,1,0,1,0],[1,1,1,1,1],[1,1,1,1,1],[0,1,1,1,0],[0,0,1,0,0]] },
            { name: "M·∫∑t C∆∞·ªùi (5x5)", size: 5, grid: [[0,1,0,1,0],[0,1,0,1,0],[0,0,0,0,0],[1,0,0,0,1],[0,1,1,1,0]] },
            { name: "Thuy·ªÅn Bu·ªìm (10x10)", size: 10, grid: [[0,0,0,1,0,0,0,0,0,0],[0,0,1,1,0,0,0,0,0,0],[0,1,1,1,0,0,1,0,0,0],[0,0,1,1,0,1,1,0,0,0],[0,0,1,1,0,0,1,0,0,0],[0,0,1,1,0,0,1,0,0,0],[0,0,0,0,0,0,1,0,0,0],[1,1,1,1,1,1,1,1,1,0],[0,1,1,1,1,1,1,1,0,0],[0,0,1,1,1,1,1,0,0,0]] },
            { name: "T√™n L·ª≠a (10x10)", size: 10, grid: [[0,0,0,0,1,1,0,0,0,0],[0,0,0,1,1,1,1,0,0,0],[0,0,1,1,1,1,1,1,0,0],[0,0,1,1,0,0,1,1,0,0],[0,0,1,1,0,0,1,1,0,0],[0,0,1,1,1,1,1,1,0,0],[0,1,1,0,1,1,0,1,1,0],[1,1,0,0,1,1,0,0,1,1],[1,1,0,0,1,1,0,0,1,1],[0,0,0,1,1,1,1,0,0,0]] },
            { name: "Con Cua (10x10)", size: 10, grid: [[0,0,1,0,0,0,0,1,0,0],[0,1,1,1,0,1,1,1,0,0],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,0,1,1,1,1,1,1,1],[1,1,0,1,1,1,1,1,1,1],[0,1,1,0,0,1,1,1,1,1],[0,1,1,0,0,1,1,1,0,0],[0,0,0,1,1,1,1,0,0,0],[0,0,0,1,1,0,0,0,0,0]] },
            { name: "Ng∆∞·ªùi Nh·ªán (10x10)", size: 10, grid: [[0,1,0,0,0,0,0,0,1,0],[1,1,1,0,0,0,0,1,1,1],[1,1,1,1,1,1,1,1,1,1],[0,1,1,1,0,0,1,1,1,0],[0,0,1,1,0,0,1,1,0,0],[0,1,0,1,1,1,1,0,1,0],[1,0,0,1,1,1,1,0,0,1],[0,0,0,0,1,1,0,0,0,0],[0,0,0,1,0,0,1,0,0,0],[0,0,0,1,0,0,1,0,0,0]] }
        ];

        let state = {
            levelIdx: 0,
            grid: [],
            tool: 'draw',
            drawMode: 'fill',
            scale: 1, panX: 0, panY: 0,
            isDragging: false, lastX: 0, lastY: 0, intention: 0,
            isWin: false
        };

        const boardEl = document.getElementById('game-board');
        const viewportEl = document.getElementById('viewport');

        function init() {
            // Level Select
            const selector = document.getElementById('level-select');
            levels.forEach((l, i) => {
                const opt = document.createElement('option');
                opt.value = i; opt.text = l.name;
                selector.appendChild(opt);
            });
            selector.addEventListener('change', (e) => loadLevel(parseInt(e.target.value)));
            
            // Events
            viewportEl.addEventListener('mousedown', onPointerDown);
            viewportEl.addEventListener('mousemove', onPointerMove);
            window.addEventListener('mouseup', onPointerUp);
            viewportEl.addEventListener('touchstart', onTouchStart, {passive: false});
            viewportEl.addEventListener('touchmove', onTouchMove, {passive: false});
            window.addEventListener('touchend', onPointerUp);
            viewportEl.addEventListener('wheel', (e) => {
                if(e.ctrlKey) { e.preventDefault(); zoom(e.deltaY > 0 ? -0.1 : 0.1); }
            }, {passive: false});

            loadLevel(0);
        }

        function loadLevel(idx) {
            state.levelIdx = idx;
            state.isWin = false;
            document.getElementById('level-select').value = idx;
            toggleWinOverlay(false, true); // Force hide win overlay
            document.getElementById('show-win-btn').classList.add('hidden');
            
            const level = levels[idx];
            state.grid = Array(level.size).fill().map(() => Array(level.size).fill(0));
            
            renderBoard(level);
            
            // Auto Center after render
            setTimeout(centerBoard, 50);
        }

        function calculateHints(line) {
            let hints = [], count = 0;
            for(let val of line) {
                if(val === 1) count++;
                else if(count > 0) { hints.push(count); count = 0; }
            }
            if(count > 0) hints.push(count);
            return hints.length ? hints : [0];
        }

        function renderBoard(level) {
            boardEl.innerHTML = '';
            const rowHints = level.grid.map(row => calculateHints(row));
            const colHints = Array(level.size).fill().map((_, j) => calculateHints(level.grid.map(row => row[j])));

            const table = document.createElement('table');
            table.style.borderCollapse = 'separate';
            table.style.borderSpacing = '0';
            
            // Header
            const trHead = document.createElement('tr');
            trHead.appendChild(document.createElement('td')); 
            colHints.forEach((hints, c) => {
                const td = document.createElement('td');
                td.className = "text-center align-bottom pb-1 px-1 min-w-[25px] select-none";
                td.id = `hint-col-${c}`;
                const div = document.createElement('div');
                div.className = "flex flex-col justify-end";
                hints.forEach(h => {
                    const sp = document.createElement('span');
                    sp.className = "hint-num block"; sp.innerText = h;
                    div.appendChild(sp);
                });
                td.appendChild(div);
                trHead.appendChild(td);
            });
            table.appendChild(trHead);

            // Body
            for(let r=0; r<level.size; r++) {
                const tr = document.createElement('tr');
                const tdHint = document.createElement('td');
                tdHint.className = "text-right pr-2 h-8 whitespace-nowrap align-middle select-none";
                tdHint.id = `hint-row-${r}`;
                rowHints[r].forEach(h => {
                    const sp = document.createElement('span');
                    sp.className = "hint-num inline-block ml-1"; sp.innerText = h;
                    tdHint.appendChild(sp);
                });
                tr.appendChild(tdHint);

                for(let c=0; c<level.size; c++) {
                    const td = document.createElement('td');
                    td.className = "w-8 h-8 border border-slate-600 bg-slate-900 cursor-pointer nonogram-cell";
                    td.dataset.r = r; td.dataset.c = c; td.id = `cell-${r}-${c}`;
                    if((c+1)%5===0 && c!==level.size-1) td.style.borderRight = "2px solid #94a3b8";
                    if((r+1)%5===0 && r!==level.size-1) td.style.borderBottom = "2px solid #94a3b8";
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
            boardEl.appendChild(table);
        }

        // --- BOARD CONTROL (PAN/ZOOM/CENTER) ---

        function centerBoard() {
            const boardRect = boardEl.getBoundingClientRect();
            const viewRect = viewportEl.getBoundingClientRect();
            
            // T√≠nh scale ƒë·ªÉ v·ª´a kh√≠t m√†n h√¨nh n·∫øu b·∫£ng qu√° to
            const padding = 40;
            const contentW = boardEl.offsetWidth;
            const contentH = boardEl.offsetHeight;
            const availW = viewRect.width - padding;
            const availH = viewRect.height - padding;
            
            let newScale = Math.min(availW / contentW, availH / contentH);
            if (newScale > 1.5) newScale = 1.5; // Kh√¥ng zoom qu√° to
            if (newScale < 0.5) newScale = 0.5;
            
            state.scale = newScale;
            
            // T√≠nh to√°n v·ªã tr√≠ center
            // Transform origin l√† 0 0, n√™n translate c·∫ßn ƒë∆∞a v·ªÅ gi·ªØa
            state.panX = (viewRect.width - contentW * state.scale) / 2;
            state.panY = (viewRect.height - contentH * state.scale) / 2;
            
            updateTransform();
        }

        function zoom(delta) {
            state.scale = Math.max(0.3, Math.min(3, state.scale + delta));
            updateTransform();
        }

        function updateTransform() {
            boardEl.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.scale})`;
        }

        // --- GAMEPLAY INPUT ---

        function onPointerDown(e) {
            if(state.isWin) return;
            e.preventDefault();
            startAction(e.clientX, e.clientY, e.target, e.button === 2);
        }
        function onTouchStart(e) {
            if(state.isWin) return;
            e.preventDefault();
            if(e.touches.length > 1) return;
            const t = e.touches[0];
            startAction(t.clientX, t.clientY, document.elementFromPoint(t.clientX, t.clientY), false);
        }

        function startAction(x, y, target, isRightClick) {
            state.isDragging = true;
            state.lastX = x; state.lastY = y;
            const cell = target ? target.closest('td[data-r]') : null;

            if (state.tool === 'pan' || !cell) {
                state.actionType = 'pan';
                viewportEl.classList.add('cursor-grabbing');
                return;
            }

            state.actionType = 'draw';
            const r = parseInt(cell.dataset.r);
            const c = parseInt(cell.dataset.c);
            const useCross = isRightClick || state.drawMode === 'cross';
            state.intention = (useCross ? (state.grid[r][c] === 2 ? 0 : 2) : (state.grid[r][c] === 1 ? 0 : 1));
            applyMove(r, c);
        }

        function onPointerMove(e) {
            if (!state.isDragging) {
                const cell = e.target.closest('td[data-r]');
                if(cell) highlightGuides(parseInt(cell.dataset.r), parseInt(cell.dataset.c));
                return;
            }
            moveAction(e.clientX, e.clientY, e.target);
        }
        function onTouchMove(e) {
            if (!state.isDragging) return;
            const t = e.touches[0];
            moveAction(t.clientX, t.clientY, document.elementFromPoint(t.clientX, t.clientY));
        }

        function moveAction(x, y, target) {
            if (state.actionType === 'pan') {
                state.panX += x - state.lastX;
                state.panY += y - state.lastY;
                state.lastX = x; state.lastY = y;
                updateTransform();
            } else if (state.actionType === 'draw' && target) {
                const cell = target.closest('td[data-r]');
                if (cell) applyMove(parseInt(cell.dataset.r), parseInt(cell.dataset.c), true);
            }
        }

        function onPointerUp() {
            state.isDragging = false;
            viewportEl.classList.remove('cursor-grabbing');
            if(!state.isWin) checkWin();
        }

        function applyMove(r, c, isDrag = false) {
            if(state.isWin) return;
            const cur = state.grid[r][c];
            if (isDrag) {
                if (state.intention === 1 && cur === 2) return;
                if (state.intention === 2 && cur === 1) return;
            }
            if (cur !== state.intention) {
                state.grid[r][c] = state.intention;
                updateCellVisual(r, c);
                checkLineComplete(r, c);
            }
        }

        function updateCellVisual(r, c) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            if(!cell) return;
            cell.className = `w-8 h-8 border border-slate-600 bg-slate-900 cursor-pointer nonogram-cell ${state.grid[r][c] === 1 ? 'cell-filled' : ''} ${state.grid[r][c] === 2 ? 'cell-crossed' : ''}`;
            // Re-apply highlight if needed (handled by mousemove usually but good for consistency)
        }

        function highlightGuides(r, c) {
            document.querySelectorAll('.cell-highlight-guide').forEach(el => el.classList.remove('cell-highlight-guide'));
            const size = levels[state.levelIdx].size;
            for(let j=0; j<size; j++) document.getElementById(`cell-${r}-${j}`)?.classList.add('cell-highlight-guide');
            for(let i=0; i<size; i++) document.getElementById(`cell-${i}-${c}`)?.classList.add('cell-highlight-guide');
        }

        function checkLineComplete(r, c) {
            const target = levels[state.levelIdx].grid;
            const size = target.length;
            
            // Check Row
            let rOk = true; for(let j=0; j<size; j++) if((state.grid[r][j]===1) !== (target[r][j]===1)) { rOk = false; break; }
            const rEl = document.getElementById(`hint-row-${r}`);
            rEl.querySelectorAll('.hint-num').forEach(el => el.classList.toggle('hint-completed', rOk));

            // Check Col
            let cOk = true; for(let i=0; i<size; i++) if((state.grid[i][c]===1) !== (target[i][c]===1)) { cOk = false; break; }
            const cEl = document.getElementById(`hint-col-${c}`);
            cEl.querySelectorAll('.hint-num').forEach(el => el.classList.toggle('hint-completed', cOk));
        }

        // --- LOGICAL HINTS SYSTEM ---

        function getLogicalHint() {
            if(state.isWin) return;
            const level = levels[state.levelIdx];
            const size = level.size;
            const target = level.grid;
            const user = state.grid;

            // Helper: Get possibilities for a line
            // Returns array where: 1=Must Fill, 0=Must Empty, -1=Unknown
            function solveLine(length, hints) {
                let validPerms = [];
                function generate(idx, hintIdx, currentLine) {
                    if(hintIdx === hints.length) {
                        // Check if remaining space can be empty
                        for(let k=idx; k<length; k++) currentLine[k] = 0;
                        validPerms.push([...currentLine]);
                        return;
                    }
                    const clue = hints[hintIdx];
                    // Try positions
                    // Max start index = length - (remaining clues + gaps)
                    // Simplified: just try all valid positions
                    for(let i=idx; i <= length - clue; i++) {
                        // Check if we can place here
                        // 1. Prev cell must be 0 (or boundary) - handled by `idx` jump
                        // 2. Next cell must be 0 (or boundary)
                        let canPlace = true;
                        if(i + clue < length) {
                            // Gap required
                        }
                        // Actually, simplified recursion:
                        // Place clue at `i`. Next recursion starts at `i + clue + 1`
                        // Ensure we fit all remaining clues
                        
                        // Remaining minimum length = sum(remaining clues) + (remaining clues - 1)
                        let remainingLen = 0;
                        for(let z=hintIdx+1; z<hints.length; z++) remainingLen += hints[z] + 1;
                        if (length - (i + clue + (remainingLen>0?1:0)) < remainingLen - (remainingLen>0?1:0)) continue; // Not enough space (heuristic)

                        let newLine = [...currentLine];
                        // Fill gaps before
                        for(let k=idx; k<i; k++) newLine[k] = 0;
                        // Fill clue
                        for(let k=0; k<clue; k++) newLine[i+k] = 1;
                        // Fill gap after (if not last)
                        if(i+clue < length) newLine[i+clue] = 0;

                        generate(i + clue + 1, hintIdx + 1, newLine);
                    }
                }
                // Very naive generator - optimized for small puzzles (<=15)
                // For 10x10 it's instant.
                generate(0, 0, Array(length).fill(0));

                if(validPerms.length === 0) return Array(length).fill(-1); // Should not happen if puzzle valid

                // Intersect
                let result = Array(length).fill(-1);
                for(let i=0; i<length; i++) {
                    let allOne = true, allZero = true;
                    for(let p of validPerms) {
                        if(p[i] === 0) allOne = false;
                        if(p[i] === 1) allZero = false;
                    }
                    if(allOne) result[i] = 1;
                    else if(allZero) result[i] = 0;
                }
                return result;
            }

            // 1. Scan Rows for Logical deductions
            for(let r=0; r<size; r++) {
                const hints = calculateHints(target[r]);
                const deduction = solveLine(size, hints);
                for(let c=0; c<size; c++) {
                    // If logic says MUST FILL but user hasn't -> Hint
                    if(deduction[c] === 1 && user[r][c] !== 1) {
                        flashCell(r, c);
                        showToast(`H√†ng ${r+1} c√≥ g·ª£i √Ω [${hints.join(', ')}]. D·ª±a tr√™n quy lu·∫≠t giao thoa, √¥ n√†y ch·∫Øc ch·∫Øn ph·∫£i T√î.`);
                        return;
                    }
                    // If logic says MUST EMPTY but user hasn't crossed -> Hint
                    if(deduction[c] === 0 && user[r][c] !== 2 && user[r][c] !== 0) {
                         // Only suggest X if user filled it wrongly. 
                         // If it's empty, suggesting X is weak hint, but valid.
                         // Let's prioritize Fills first.
                    }
                }
            }

            // 2. Scan Cols
            for(let c=0; c<size; c++) {
                const col = []; for(let r=0; r<size; r++) col.push(target[r][c]);
                const hints = calculateHints(col);
                const deduction = solveLine(size, hints);
                for(let r=0; r<size; r++) {
                    if(deduction[r] === 1 && user[r][c] !== 1) {
                        flashCell(r, c);
                        showToast(`C·ªôt ${c+1} c√≥ g·ª£i √Ω [${hints.join(', ')}]. Logic cho th·∫•y √¥ n√†y ph·∫£i T√î.`);
                        return;
                    }
                }
            }

            // 3. Fallback: Find a simple "Line Complete" hint (Filling Xs)
            for(let r=0; r<size; r++) {
                const hints = calculateHints(target[r]);
                // Check if filled count matches hint sum (naive check)
                let fillCount = user[r].filter(x=>x===1).length;
                let hintSum = hints.reduce((a,b)=>a+b, 0);
                if(fillCount === hintSum) {
                    // Check if the arrangement is actually correct first
                    let isCorrectArrangement = JSON.stringify(calculateHints(user[r])) === JSON.stringify(hints);
                    if(isCorrectArrangement) {
                        // Find empty spot to X
                        for(let c=0; c<size; c++) {
                            if(user[r][c] === 0) {
                                state.grid[r][c] = 2; updateCellVisual(r,c); flashCell(r,c);
                                showToast(`H√†ng ${r+1} ƒë√£ ƒë·ªß s·ªë √¥ ƒëen. H√£y ƒë√°nh d·∫•u X v√†o c√°c √¥ tr·ªëng c√≤n l·∫°i.`);
                                return;
                            }
                        }
                    }
                }
            }

            // 4. Last Resort: Reveal a random cell
            showToast("H·ªá th·ªëng ch∆∞a t√¨m th·∫•y b∆∞·ªõc ƒëi logic ƒë∆°n gi·∫£n. ƒê√¢y l√† m·ªôt g·ª£i √Ω ng·∫´u nhi√™n.");
            let moves = [];
            for(let i=0; i<size; i++) for(let j=0; j<size; j++) if(user[i][j]===0 && target[i][j]===1) moves.push({r:i,c:j});
            if(moves.length) {
                const m = moves[Math.floor(Math.random()*moves.length)];
                state.grid[m.r][m.c] = 1; updateCellVisual(m.r,m.c); flashCell(m.r,m.c); checkLineComplete(m.r,m.c);
            }
        }

        // --- ANSWER REVEAL ---
        function showAnswer() {
            if(!confirm("B·∫°n c√≥ ch·∫Øc mu·ªën xem to√†n b·ªô ƒë√°p √°n? S·∫Ω m·∫•t ƒëi s·ª± th√∫ v·ªã ƒë√≥!")) return;
            const target = levels[state.levelIdx].grid;
            const size = target.length;
            
            // Fill grid with target
            for(let i=0; i<size; i++) {
                for(let j=0; j<size; j++) {
                    state.grid[i][j] = target[i][j];
                    updateCellVisual(i, j);
                }
            }
            // Update hint visuals (cross out numbers)
            for(let i=0; i<size; i++) for(let j=0; j<size; j++) checkLineComplete(i, j);
        }

        function showToast(msg) {
            const t = document.getElementById('hint-toast');
            document.getElementById('hint-text').innerText = msg;
            t.classList.remove('hidden');
            // Reset anim
            t.classList.remove('toast-anim');
            void t.offsetWidth; 
            t.classList.add('toast-anim');
            
            setTimeout(() => t.classList.add('hidden'), 5000);
        }

        function flashCell(r, c) {
            const cell = document.getElementById(`cell-${r}-${c}`);
            if(cell) { cell.classList.add('hint-anim'); setTimeout(()=>cell.classList.remove('hint-anim'), 800); }
        }

        // --- WIN SYSTEM ---

        function checkWin() {
            if(state.isWin) return;
            const target = levels[state.levelIdx].grid;
            const size = state.grid.length;
            for(let i=0; i<size; i++) for(let j=0; j<size; j++) if((state.grid[i][j]===1) !== (target[i][j]===1)) return;
            
            // Win!
            state.isWin = true;
            document.getElementById('level-name-display').innerText = levels[state.levelIdx].name;
            document.getElementById('show-win-btn').classList.add('hidden');
            toggleWinOverlay(true);
        }

        function toggleWinOverlay(show, forceHide=false) {
            const overlay = document.getElementById('win-overlay');
            const btn = document.getElementById('show-win-btn');
            
            if(forceHide) {
                overlay.classList.add('hidden');
                btn.classList.add('hidden');
                return;
            }

            if(show) {
                overlay.classList.remove('hidden');
                btn.classList.add('hidden');
            } else {
                overlay.classList.add('hidden');
                if(state.isWin) btn.classList.remove('hidden'); // Show peek button
            }
        }

        function toggleRules() {
            const el = document.getElementById('rules-modal');
            el.classList.toggle('hidden');
        }

        function nextLevel() {
            let next = state.levelIdx + 1;
            if (next >= levels.length) next = 0;
            loadLevel(next);
        }
        function replayLevel() { loadLevel(state.levelIdx); }
        function resetGame() { replayLevel(); }
        function setTool(t) {
            state.tool = t;
            document.getElementById('tool-draw').className = t === 'draw' ? "btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1" : "btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1 transition-colors";
            document.getElementById('tool-pan').className = t === 'pan' ? "btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1" : "btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1 transition-colors";
            document.getElementById('draw-modes').style.opacity = t === 'draw' ? '1' : '0.3';
            viewportEl.style.cursor = t === 'draw' ? 'crosshair' : 'grab';
        }
        function setDrawMode(m) {
            state.drawMode = m;
            document.getElementById('mode-fill').className = m === 'fill' ? "btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1" : "btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1";
            document.getElementById('mode-cross').className = m === 'cross' ? "btn-tool btn-active px-3 py-1.5 rounded text-xs flex items-center gap-1" : "btn-tool px-3 py-1.5 rounded text-slate-400 hover:text-white text-xs flex items-center gap-1";
            if(state.tool !== 'draw') setTool('draw');
        }

        init();
    </script>
</body>
</html>
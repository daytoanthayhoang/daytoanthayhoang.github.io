<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>√în t·∫≠p Chinh Ph·ª•c To√°n 7 HK1 - C√¢u 7</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    
    <!-- MathJax Configuration -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            startup: {
                typeset: false
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap');
        
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #fff7ed; /* Orange-50 */
        }

        .btn-option {
            transition: all 0.2s ease;
            touch-action: manipulation;
        }
        
        .btn-option:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .btn-option:active:not(:disabled) {
            transform: scale(0.98);
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }
        .shake {
            animation: shake 0.3s ease-in-out;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .pop {
            animation: pop 0.2s ease-out;
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .mode-active {
            background-color: #ea580c; /* orange-600 */
            color: white;
            border-color: #ea580c;
        }

        .mode-inactive {
            background-color: white;
            color: #374151;
            border-color: #d1d5db;
        }
        .mode-inactive:hover {
            background-color: #ffedd5; /* orange-100 */
        }

        /* Loading Overlay */
        #question-loader {
            position: absolute;
            inset: 0;
            background-color: white;
            z-index: 50;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: opacity 0.2s ease-out;
        }
        .loader-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #ea580c; /* Orange-600 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .hidden-loader {
            opacity: 0;
            pointer-events: none;
        }

        #main-content-wrapper {
            opacity: 0;
        }
        #main-content-wrapper.content-visible {
            opacity: 1;
            transition: opacity 0.3s ease-in;
        }

        /* SVG Styles */
        .geometry-svg {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
            border: 1px dashed #fdba74; /* Orange-300 */
            border-radius: 8px;
            background-color: #fff;
            overflow: visible; 
        }
        .geo-line { stroke: #333; stroke-width: 2; stroke-linecap: round; }
        .geo-ray { stroke: #ea580c; stroke-width: 2; }
        .geo-text { font-size: 16px; font-weight: bold; fill: #1f2937; font-family: 'Nunito', sans-serif; }
        .geo-label-box { fill: #fff7ed; stroke: #ea580c; stroke-width: 1; rx: 4; }
        .geo-point { fill: #ea580c; }
        .geo-point-label { fill: #ea580c; font-size: 14px; font-weight: bold; }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">

    <!-- Header -->
    <header class="w-full max-w-3xl text-center mb-6">
        <h1 class="text-2xl md:text-3xl font-extrabold text-orange-800 mb-2 uppercase drop-shadow-sm">
            <i class="fas fa-shapes mr-2"></i>√în t·∫≠p chinh ph·ª•c To√°n 7 HK1 - C√¢u 7
        </h1>
        <p class="text-orange-600 font-medium">Ch·ªß ƒë·ªÅ: Hai g√≥c k·ªÅ b√π & Hai g√≥c ƒë·ªëi ƒë·ªânh</p>
    </header>

    <!-- Mode Selection -->
    <div class="w-full max-w-3xl grid grid-cols-2 md:grid-cols-4 gap-2 mb-6">
        <button onclick="setMode('all')" id="btn-mode-all" class="mode-active py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform transform scale-105">
            <i class="fas fa-random mb-1"></i> T·ªïng H·ª£p
        </button>
        <button onclick="setMode('kebu')" id="btn-mode-kebu" class="mode-inactive py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform">
            <i class="fas fa-arrows-alt-h mb-1"></i> G√≥c K·ªÅ B√π
        </button>
        <button onclick="setMode('doidinh')" id="btn-mode-doidinh" class="mode-inactive py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform">
            <i class="fas fa-times mb-1"></i> ƒê·ªëi ƒê·ªânh & Quan H·ªá
        </button>
        <button onclick="setMode('complex')" id="btn-mode-complex" class="mode-inactive py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform">
            <i class="fas fa-project-diagram mb-1"></i> Ph·ª©c t·∫°p
        </button>
    </div>

    <!-- Stats Board -->
    <div class="w-full max-w-3xl bg-white rounded-xl shadow-md p-4 mb-6 grid grid-cols-4 gap-2 text-center select-none" id="stats-container">
        <!-- Rendered by JS -->
    </div>

    <!-- Question Card -->
    <div class="w-full max-w-3xl bg-white rounded-2xl shadow-lg border-b-4 border-orange-600 p-6 relative overflow-hidden" style="min-height: 400px;">
        
        <!-- Loading Overlay -->
        <div id="question-loader">
            <div class="loader-spinner mb-3"></div>
            <span class="text-orange-600 font-bold text-sm">ƒêang v·∫Ω h√¨nh & sinh c√¢u h·ªèi...</span>
        </div>

        <!-- Question Badge -->
        <div class="absolute top-0 left-0 bg-orange-100 text-orange-800 px-3 py-1 rounded-br-lg text-xs font-bold uppercase z-10" id="question-type-badge">
            D·∫°ng c√¢u h·ªèi
        </div>

        <!-- CONTENT WRAPPER -->
        <div id="main-content-wrapper" class="flex flex-col h-full justify-between pt-6">
            
            <!-- Question Content -->
            <div class="mb-6 fade-in">
                <!-- Image Container -->
                <div id="image-container" class="mb-4 flex justify-center hidden" style="min-height: 200px;">
                    <!-- SVG will be injected here -->
                </div>

                <h2 class="text-xl md:text-2xl font-bold text-gray-800 text-left leading-relaxed" id="question-text">
                    <!-- Question goes here -->
                </h2>
            </div>

            <!-- Options Grid -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6" id="options-container">
                <!-- Buttons will be injected here -->
            </div>

            <!-- Explanation Area -->
            <div id="explanation-area" class="hidden mb-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-lg text-gray-700 text-sm md:text-base fade-in">
                 <!-- JS will inject content -->
            </div>

            <!-- Feedback & Next -->
            <div class="mt-auto h-12 flex items-center justify-between">
                <div id="feedback-msg" class="text-lg font-bold hidden pl-2"></div>
                <button onclick="handleNextClick()" id="btn-next" class="bg-white border border-gray-300 text-gray-600 px-6 py-2 rounded-full font-bold hover:bg-orange-100 transition flex items-center ml-auto shadow-sm">
                    B·ªè qua <i class="fas fa-forward ml-2"></i>
                </button>
            </div>
        </div>
    </div>

    <footer class="mt-auto py-6 text-center text-gray-400 text-xs">
        ¬© Th·∫ßy Nguy·ªÖn Vi·ªát Ho√†ng - Tr∆∞·ªùng THCS Nguy·ªÖn An Kh∆∞∆°ng - daytoanthayhoang.github.io
    </footer>

    <!-- Feedback Modal (Overlay) -->
    <div id="feedback-overlay" class="fixed inset-0 bg-black/50 z-50 hidden flex items-center justify-center p-4 fade-in">
        <div class="bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6 text-center relative">
            <div id="feedback-icon" class="text-6xl mb-4"></div>
            <h3 id="feedback-title" class="text-2xl font-bold mb-2"></h3>
            <p id="feedback-message" class="text-gray-700 mb-4 text-lg font-medium"></p>
            <div class="bg-orange-50 p-4 rounded-xl text-left mb-6">
                <p class="text-xs text-orange-500 font-bold uppercase mb-1">Gi·∫£i th√≠ch chi ti·∫øt:</p>
                <div id="feedback-detail" class="text-gray-800 text-sm leading-relaxed"></div>
            </div>
            <button onclick="closeModal()" class="w-full py-3 bg-orange-600 text-white font-bold rounded-xl shadow-lg hover:bg-orange-700 transition transform hover:-translate-y-1">
                ƒê√≥ng ƒë·ªÉ xem l·∫°i <i class="fas fa-times ml-2"></i>
            </button>
        </div>
    </div>

    <script>
        // --- DATA & STATE ---
        const state = {
            mode: 'all', // all, kebu, doidinh, complex
            streak: 0,
            correct: 0,
            wrong: 0,
            skipped: 0,
            currentQuestion: null,
            isAnswered: false
        };

        // --- UTILS ---
        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        // --- NAME GENERATOR ---
        const generateLabels = (count) => {
            const isUnfamiliar = Math.random() < 0.4;
            const useUpperCase = Math.random() < 0.5;

            // X√°c ƒë·ªãnh t√¢m tr∆∞·ªõc ƒë·ªÉ l·ªçc kh·ªèi pool
            const center = (isUnfamiliar && useUpperCase) ? 'I' : 'O';

            let pool;
            if (useUpperCase) {
                // T√™n ƒêi·ªÉm (In hoa) - ƒê·∫£m b·∫£o ƒë·ªß √≠t nh·∫•t 7-8 k√Ω t·ª±
                if (isUnfamiliar) pool = ['M', 'N', 'P', 'Q', 'E', 'F', 'H', 'K', 'J', 'L'];
                else pool = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'];
            } else {
                // T√™n ƒë∆∞·ªùng th·∫≥ng/tia (In th∆∞·ªùng) - Tr√°nh ch·ªØ 'l' d·ªÖ nh·∫ßm l·∫´n
                if (isUnfamiliar) pool = ['u', 'v', 'm', 'n', 'a', 'b', 'h', 'k'];
                else pool = ['x', 'y', 'z', 't', 'k', 'p', 'q', 'r'];
            }
            
            // L·ªçc t√™n t√¢m ra kh·ªèi pool ƒë·ªÉ tr√°nh tr√πng (V√≠ d·ª• t√¢m l√† I th√¨ trong pool kh√¥ng ƒë∆∞·ª£c c√≥ I)
            pool = pool.filter(c => c !== center);

            // N·∫øu pool kh√¥ng ƒë·ªß (√≠t g·∫∑p), l·∫•y th√™m t·ª´ pool kh√°c nh∆∞ng ph·∫£i tr√°nh t√¢m
            while(pool.length < count) {
                const backups = ['X', 'Y', 'Z', 'W', 'S', 'R'].filter(c => c !== center);
                pool.push(...backups);
                // Lo·∫°i b·ªè tr√πng l·∫∑p n·∫øu th√™m nhi·ªÅu l·∫ßn
                pool = [...new Set(pool)];
            }

            return {
                labels: shuffleArray(pool).slice(0, count),
                isUpper: useUpperCase,
                center: center
            };
        };

        // --- SVG DRAWING HELPERS ---
        const createSVG = (width, height) => {
            return `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" xmlns="http://www.w3.org/2000/svg" class="geometry-svg">`;
        };

        const drawLine = (x1, y1, x2, y2, color="#333", width=2) => {
            return `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" stroke="${color}" stroke-width="${width}" stroke-linecap="round"/>`;
        };

        const drawText = (x, y, text, color="#1f2937", size=16) => {
            return `<text x="${x}" y="${y}" fill="${color}" font-family="Nunito" font-weight="bold" font-size="${size}" text-anchor="middle" dominant-baseline="middle">${text}</text>`;
        };
        
        const drawPoint = (x, y, label=null, labelOffset={dx:0, dy:-15}) => {
            let svg = `<circle cx="${x}" cy="${y}" r="3" fill="#ea580c"/>`;
            if (label) {
                svg += drawText(x + labelOffset.dx, y + labelOffset.dy, label);
            }
            return svg;
        };

        // H√†m v·∫Ω tia th√¥ng minh: X·ª≠ l√Ω v·ª• in hoa/in th∆∞·ªùng
        const drawSmartRay = (cx, cy, angleDeg, label, isUpper, length = 90) => {
            const rad = (angleDeg * Math.PI) / 180;
            const ex = cx + length * Math.cos(rad);
            const ey = cy + length * Math.sin(rad); 
            
            const labelDist = 18;
            const lx = ex + labelDist * Math.cos(rad);
            const ly = ey + labelDist * Math.sin(rad);

            let svg = "";
            
            if (isUpper) {
                // In hoa
                const extension = 25;
                const extX = cx + (length + extension) * Math.cos(rad);
                const extY = cy + (length + extension) * Math.sin(rad);
                
                svg += drawLine(cx, cy, extX, extY, "#333");
                svg += drawPoint(ex, ey);
                
                const perpX = -Math.sin(rad) * 18;
                const perpY = Math.cos(rad) * 18;
                svg += drawText(ex + perpX, ey + perpY, label); 

            } else {
                // In th∆∞·ªùng
                svg += drawLine(cx, cy, ex, ey, "#333");
                svg += drawText(lx, ly, label);
            }
            return svg;
        };

        // --- GENERATORS ---

        // ================= G√ìC K·ªÄ B√ô (C∆° b·∫£n) =================
        const generateKeBu = () => {
            const labelData = generateLabels(3);
            const labels = labelData.labels;
            const isUpper = labelData.isUpper;
            const O = labelData.center;
            
            const angle1 = randomInt(40, 140);
            const angle2 = 180 - angle1;
            
            const W = 300, H = 200, CX = 150, CY = 120;
            let drawing = createSVG(W, H);

            drawing += drawSmartRay(CX, CY, 180, labels[0], isUpper, 100); 
            drawing += drawSmartRay(CX, CY, 0, labels[1], isUpper, 100);   
            
            // Tia th·ª© 3
            drawing += drawSmartRay(CX, CY, -angle2, labels[2], isUpper, 90);

            drawing += drawPoint(CX, CY, O, {dx: 0, dy: 25});

            const rad = (-angle2 * Math.PI) / 180;
            drawing += `<path d="M ${CX+30} ${CY} A 30 30 0 0 0 ${CX + 30*Math.cos(rad)} ${CY + 30*Math.sin(rad)}" fill="none" stroke="blue" stroke-width="2"/>`;
            
            drawing += "</svg>";
            
            const formatAngle = (ray1, ray2) => {
                if (isUpper) return `$\\widehat{${ray1}${O}${ray2}}$`;
                return `$\\widehat{${ray1}${O}${ray2}}$`;
            };

            const angleLeftName = formatAngle(labels[0], labels[2]);
            const angleRightName = formatAngle(labels[2], labels[1]);
            const askName = Math.random() < 0.5 ? angleLeftName : angleRightName;
            const givenName = askName === angleLeftName ? angleRightName : angleLeftName;
            const givenVal = askName === angleLeftName ? angle2 : angle1;
            const correctVal = 180 - givenVal;

            let question, correct, options, explanation;

            if (Math.random() < 0.7) {
                question = `Quan s√°t h√¨nh v·∫Ω. Bi·∫øt ${givenName} = $${givenVal}^\\circ$. S·ªë ƒëo c·ªßa g√≥c ${askName} l√†:`;
                correct = `$${correctVal}^\\circ$`;
                const w1 = `$${givenVal}^\\circ$`;
                const w2 = `$${Math.abs(90 - givenVal)}^\\circ$`;
                const w3 = `$${randomInt(20, 160)}^\\circ$`;
                options = shuffleArray([correct, w1, w2, w3]);
                explanation = `Quan s√°t h√¨nh v·∫Ω, ta th·∫•y ${givenName} v√† ${askName} l√† hai g√≥c k·ªÅ b√π. T·ªïng s·ªë ƒëo l√† $180^\\circ$.<br>Do ƒë√≥: ${askName} = $180^\\circ - ${givenVal}^\\circ = ${correctVal}^\\circ$.`;
            } else {
                question = `Trong h√¨nh v·∫Ω tr√™n, c·∫∑p g√≥c n√†o l√† hai g√≥c k·ªÅ b√π?`;
                correct = `${givenName} v√† ${askName}`;
                const flatAngle = formatAngle(labels[0], labels[1]);
                options = shuffleArray([
                    correct,
                    `${givenName} v√† ${flatAngle}`,
                    "Hai g√≥c ƒë·ªëi ƒë·ªânh",
                    "Kh√¥ng c√≥ c·∫∑p n√†o"
                ]);
                explanation = `Hai g√≥c ${givenName} v√† ${askName} c√≥ chung c·∫°nh $O${labels[2]}$, hai c·∫°nh c√≤n l·∫°i n·∫±m tr√™n m·ªôt ƒë∆∞·ªùng th·∫≥ng.`;
            }

            return { typeLabel: "G√≥c K·ªÅ B√π", text: question, correct, options, explanation, svg: drawing };
        };

        // ================= QUAN H·ªÜ G√ìC (C∆° b·∫£n) =================
        const generateQuanHeGoc = () => {
            const labelData = generateLabels(4); 
            const l = labelData.labels;
            const isUpper = labelData.isUpper;
            const O = labelData.center;
            
            const angle = randomInt(40, 140);
            const tilt = randomInt(-15, 15);
            const W = 300, H = 220, CX = 150, CY = 110;
            let drawing = createSVG(W, H);

            drawing += drawSmartRay(CX, CY, 180 + tilt, l[0], isUpper, 100);
            drawing += drawSmartRay(CX, CY, tilt, l[1], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180 + tilt + angle, l[2], isUpper, 100);
            drawing += drawSmartRay(CX, CY, tilt + angle, l[3], isUpper, 100);
            
            drawing += drawPoint(CX, CY, O, {dx: 0, dy: -25});
            drawing += "</svg>";

            const getName = (r1, r2) => isUpper ? `$\\widehat{${r1}${O}${r2}}$` : `$\\widehat{${r1}${O}${r2}}$`;
            
            const angles = [
                { id: 0, name: getName(l[1], l[3]), rays: [l[1], l[3]] },
                { id: 1, name: getName(l[3], l[0]), rays: [l[3], l[0]] },
                { id: 2, name: getName(l[0], l[2]), rays: [l[0], l[2]] },
                { id: 3, name: getName(l[2], l[1]), rays: [l[2], l[1]] }
            ];

            const i1 = randomInt(0, 3);
            let i2; do { i2 = randomInt(0, 3); } while (i1 === i2);
            
            const ang1 = angles[i1];
            const ang2 = angles[i2];
            const diff = Math.abs(i1 - i2);
            const isAdj = (diff === 1 || diff === 3);
            
            let correct, expl;
            if (isAdj) {
                correct = "Hai g√≥c k·ªÅ b√π";
                const common = ang1.rays.find(r => ang2.rays.includes(r));
                expl = `Hai g√≥c ${ang1.name} v√† ${ang2.name} c√≥ c·∫°nh chung l√† $${isUpper?"":"O"}${common}$, hai c·∫°nh c√≤n l·∫°i l√† hai tia ƒë·ªëi nhau.`;
            } else {
                correct = "Hai g√≥c ƒë·ªëi ƒë·ªânh";
                expl = `Hai g√≥c ${ang1.name} v√† ${ang2.name} c√≥ ƒë·ªânh chung l√† ${O}, v√† c√°c c·∫°nh c·ªßa g√≥c n√†y l√† tia ƒë·ªëi c·ªßa c√°c c·∫°nh g√≥c kia.`;
            }

            const question = `Quan s√°t h√¨nh v·∫Ω. Hai g√≥c ${ang1.name} v√† ${ang2.name} l√†:`;
            const staticOptions = ["Hai g√≥c k·ªÅ b√π", "Hai g√≥c ƒë·ªëi ƒë·ªânh", "Hai g√≥c k·ªÅ nhau", "Hai g√≥c b·∫πt"];
            
            return { typeLabel: "Quan h·ªá g√≥c", text: question, correct: correct, options: shuffleArray(staticOptions), explanation: expl, svg: drawing };
        };

        // ================= G√ìC ƒê·ªêI ƒê·ªàNH (Wrapper) =================
        const generateDoiDinh = () => {
            if (Math.random() < 0.7) return generateQuanHeGoc();
            
            // Logic t√≠nh to√°n g√≥c ƒë·ªëi ƒë·ªânh c∆° b·∫£n...
            const labelData = generateLabels(4); 
            const labels = labelData.labels;
            const isUpper = labelData.isUpper;
            const O = labelData.center;
            const angle = randomInt(40, 140);
            const tilt = randomInt(-20, 20); 
            const W = 300, H = 240, CX = 150, CY = 120;
            let drawing = createSVG(W, H);
            drawing += drawSmartRay(CX, CY, 180 + tilt, labels[0], isUpper, 90);
            drawing += drawSmartRay(CX, CY, tilt, labels[1], isUpper, 90);
            drawing += drawSmartRay(CX, CY, 180 + tilt + angle, labels[2], isUpper, 90);
            drawing += drawSmartRay(CX, CY, tilt + angle, labels[3], isUpper, 90);
            drawing += drawPoint(CX, CY, O, {dx: 0, dy: -25});
            drawing += "</svg>";
            const getName = (r1, r2) => isUpper ? `$\\widehat{${r1}${O}${r2}}$` : `$\\widehat{${r1}${O}${r2}}$`;
            const angleObjs = [
                { name: getName(labels[1], labels[3]), val: angle },
                { name: getName(labels[3], labels[0]), val: 180 - angle },
                { name: getName(labels[0], labels[2]), val: angle },
                { name: getName(labels[2], labels[1]), val: 180 - angle }
            ];
            const knownIdx = randomInt(0, 3);
            const knownAngle = angleObjs[knownIdx];
            let askIdx; do { askIdx = randomInt(0, 3); } while (askIdx === knownIdx);
            const askAngle = angleObjs[askIdx];
            const isOpposite = (Math.abs(knownIdx - askIdx) === 2);
            
            const question = `Quan s√°t h√¨nh v·∫Ω. Bi·∫øt s·ªë ƒëo ${knownAngle.name} = $${knownAngle.val}^\\circ$. S·ªë ƒëo c·ªßa g√≥c ${askAngle.name} l√†:`;
            const correct = `$${askAngle.val}^\\circ$`;
            const options = shuffleArray([correct, `$${180 - askAngle.val}^\\circ$`, `$90^\\circ$`, `$${Math.abs(askAngle.val - 10)}^\\circ$`]);
            let explanation = isOpposite 
                ? `Hai g√≥c ${knownAngle.name} v√† ${askAngle.name} l√† hai g√≥c <b>ƒë·ªëi ƒë·ªânh</b> n√™n b·∫±ng nhau.` 
                : `Hai g√≥c ${knownAngle.name} v√† ${askAngle.name} l√† hai g√≥c <b>k·ªÅ b√π</b> n√™n t·ªïng b·∫±ng $180^\\circ$.`;

            return { typeLabel: "T√≠nh G√≥c", text: question, correct, options, explanation, svg: drawing };
        };

        // ================= PH·∫¶N PH·ª®C T·∫†P: NHI·ªÄU ƒê∆Ø·ªúNG, TIA GI·∫¢, H√åNH ·∫¢NH =================

        // 1. Nhi·ªÅu ƒë∆∞·ªùng th·∫≥ng c·∫Øt nhau (3 ƒë∆∞·ªùng) - LOGIC ƒêA D·∫†NG
        const generateMultiLines = () => {
            const labelData = generateLabels(6);
            const l = labelData.labels; // 6 labels
            const isUpper = labelData.isUpper;
            const O = labelData.center;
            
            const W = 320, H = 260, CX = 160, CY = 130;
            let drawing = createSVG(W, H);
            
            // G√≥c ng·∫´u nhi√™n
            const baseAngle1 = randomInt(45, 75);
            const baseAngle2 = randomInt(45, 75);
            
            // V·∫Ω 3 ƒë∆∞·ªùng th·∫≥ng: l[0]-l[1], l[2]-l[3], l[4]-l[5]
            drawing += drawSmartRay(CX, CY, 0, l[0], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180, l[1], isUpper, 100); // Line 1
            
            drawing += drawSmartRay(CX, CY, -baseAngle1, l[2], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180 - baseAngle1, l[3], isUpper, 100); // Line 2
            
            const totalAng = baseAngle1 + baseAngle2;
            drawing += drawSmartRay(CX, CY, -totalAng, l[4], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180 - totalAng, l[5], isUpper, 100); // Line 3
            
            drawing += drawPoint(CX, CY, O, {dx: 0, dy: 25});
            drawing += "</svg>";
            
            const getName = (r1, r2) => isUpper ? `$\\widehat{${r1}${O}${r2}}$` : `$\\widehat{${r1}${O}${r2}}$`;
            
            // Map tia ƒë·ªëi
            const oppMap = {};
            oppMap[l[0]] = l[1]; oppMap[l[1]] = l[0];
            oppMap[l[2]] = l[3]; oppMap[l[3]] = l[2];
            oppMap[l[4]] = l[5]; oppMap[l[5]] = l[4];

            // Ch·ªçn ng·∫´u nhi√™n 2 tia kh√¥ng tr√πng v√† kh√¥ng ƒë·ªëi nhau ƒë·ªÉ t·∫°o G√≥c G·ªëc
            const rays = [l[0], l[1], l[2], l[3], l[4], l[5]];
            const r1 = rays[randomInt(0, 5)];
            let r2;
            do { r2 = rays[randomInt(0, 5)]; } while (r2 === r1 || r2 === oppMap[r1]); 

            const ang1 = getName(r1, r2);
            
            // Logic linh ho·∫°t: h·ªèi ƒë·ªëi ƒë·ªânh ho·∫∑c k·ªÅ b√π
            const qType = Math.random() < 0.5 ? 'dd' : 'kb';
            let question, correct, explanation, wrong1, wrong2, wrong3;

            if (qType === 'dd') {
                const r1_opp = oppMap[r1];
                const r2_opp = oppMap[r2];
                const angOpp = getName(r1_opp, r2_opp);
                
                question = `Cho 3 ƒë∆∞·ªùng th·∫≥ng c·∫Øt nhau t·∫°i ${O}. G√≥c ƒë·ªëi ƒë·ªânh v·ªõi g√≥c ${ang1} l√†:`;
                correct = angOpp;
                
                // Nhi·ªÖu: G√≥c k·ªÅ b√π, G√≥c b·∫πt
                wrong1 = getName(r1, r2_opp); // K·ªÅ b√π
                wrong2 = getName(r1_opp, r2); // K·ªÅ b√π kh√°c
                wrong3 = getName(l[0], l[1]); // G√≥c b·∫πt
                explanation = `G√≥c ƒë·ªëi ƒë·ªânh v·ªõi ${ang1} ƒë∆∞·ª£c t·∫°o b·ªüi tia ƒë·ªëi c·ªßa $O${r1}$ (l√† $O${r1_opp}$) v√† tia ƒë·ªëi c·ªßa $O${r2}$ (l√† $O${r2_opp}$).`;
            } else {
                const r2_opp = oppMap[r2]; // Tia ƒë·ªëi c·∫°nh 2
                const angKb = getName(r1, r2_opp);
                
                question = `Cho 3 ƒë∆∞·ªùng th·∫≥ng c·∫Øt nhau t·∫°i ${O}. M·ªôt g√≥c k·ªÅ b√π v·ªõi g√≥c ${ang1} l√†:`;
                correct = angKb;
                
                // Nhi·ªÖu: ƒê·ªëi ƒë·ªânh, K·ªÅ nh∆∞ng ko b√π (random)
                wrong1 = getName(oppMap[r1], oppMap[r2]); // ƒê·ªëi ƒë·ªânh
                // T√¨m tia r_x k·ªÅ v·ªõi r1 nh∆∞ng ko ph·∫£i r2 v√† ko ph·∫£i ƒë·ªëi r2
                let r_x = rays.find(r => r !== r1 && r !== r2 && r !== r2_opp && r !== oppMap[r1]);
                wrong2 = getName(r1, r_x || l[0]); 
                wrong3 = "Kh√¥ng c√≥ g√≥c n√†o";
                
                explanation = `G√≥c k·ªÅ b√π v·ªõi ${ang1} c√≥ chung c·∫°nh $O${r1}$ v√† c·∫°nh c√≤n l·∫°i l√† tia ƒë·ªëi c·ªßa $O${r2}$ (l√† $O${r2_opp}$).`;
            }
            
            const options = shuffleArray([correct, wrong1, wrong2, wrong3]);
            return { typeLabel: "Nhi·ªÅu ƒë∆∞·ªùng th·∫≥ng", text: question, correct, options, explanation, svg: drawing };
        };

        // 2. ƒê∆∞·ªùng th·∫≥ng + Tia gi·∫£ - LOGIC ƒêA D·∫†NG
        const generateFakeRays = () => {
            const labelData = generateLabels(5); 
            const l = labelData.labels; // 0-1 (Line1), 2-3 (Line2), 4 (Fake)
            const isUpper = labelData.isUpper;
            const O = labelData.center;
            
            const W = 320, H = 260, CX = 160, CY = 130;
            let drawing = createSVG(W, H);
            
            // Randomize position
            const baseAngle = randomInt(40, 60);
            
            drawing += drawSmartRay(CX, CY, 0, l[0], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180, l[1], isUpper, 100); // Line 1
            
            drawing += drawSmartRay(CX, CY, -baseAngle, l[2], isUpper, 100);
            drawing += drawSmartRay(CX, CY, 180 - baseAngle, l[3], isUpper, 100); // Line 2
            
            // Tia gi·∫£ l[4] n·∫±m gi·ªØa l[2] v√† l[0] ho·∫∑c v·ªã tr√≠ kh√°c
            const fakeOffset = randomInt(15, baseAngle - 15);
            drawing += drawSmartRay(CX, CY, -fakeOffset, l[4], isUpper, 90);
            
            drawing += drawPoint(CX, CY, O, {dx: 0, dy: 25});
            drawing += "</svg>";
            
            const getName = (r1, r2) => isUpper ? `$\\widehat{${r1}${O}${r2}}$` : `$\\widehat{${r1}${O}${r2}}$`;
            
            // 4 K·ªãch b·∫£n c√¢u h·ªèi
            const scenario = randomInt(1, 4);
            let question, correct, explanation;
            const optionsList = []; // ƒê·ªÉ shuffle sau

            if (scenario === 1) { // H·ªèi ƒë·ªëi ƒë·ªânh c·ªßa g√≥c CH·ª®A tia gi·∫£ (Kh√¥ng c√≥)
                const fakeAng = getName(l[4], l[1]);
                question = `G√≥c ƒë·ªëi ƒë·ªânh v·ªõi g√≥c ${fakeAng} l√† g√≥c n√†o?`;
                correct = "Kh√¥ng c√≥ g√≥c n√†o";
                optionsList.push(getName(l[0], l[3]), getName(l[2], l[0]), getName(l[3], l[4]));
                explanation = `V√¨ tia $O${l[4]}$ kh√¥ng ph·∫£i l√† tia ƒë·ªëi c·ªßa b·∫•t k·ª≥ tia n√†o trong h√¨nh, n√™n g√≥c ${fakeAng} kh√¥ng c√≥ g√≥c ƒë·ªëi ƒë·ªânh.`;
            } 
            else if (scenario === 2) { // H·ªèi ƒë·ªëi ƒë·ªânh TH·∫¨T (nh∆∞ng c√≥ ƒë√°p √°n nhi·ªÖu l√† tia gi·∫£)
                const realAng = getName(l[3], l[1]);
                const realOpp = getName(l[2], l[0]);
                question = `G√≥c ƒë·ªëi ƒë·ªânh v·ªõi g√≥c ${realAng} l√†:`;
                correct = realOpp;
                optionsList.push(getName(l[2], l[4]), "Kh√¥ng c√≥ g√≥c n√†o", getName(l[1], l[4]));
                explanation = `G√≥c ƒë·ªëi ƒë·ªânh ƒë∆∞·ª£c t·∫°o b·ªüi c√°c tia ƒë·ªëi c·ªßa c·∫°nh g√≥c ƒë√£ cho ($O${l[2]}$ ƒë·ªëi $O${l[3]}$, $O${l[0]}$ ƒë·ªëi $O${l[1]}$).`;
            } 
            else if (scenario === 3) { // H·ªèi k·ªÅ b√π v·ªõi g√≥c CH·ª®A tia gi·∫£ (V·∫´n c√≥)
                // G√≥c (4, 1) k·ªÅ b√π v·ªõi (4, 0) v√¨ 1 ƒë·ªëi 0
                const target = getName(l[4], l[1]);
                const supp = getName(l[4], l[0]);
                question = `G√≥c k·ªÅ b√π v·ªõi g√≥c ${target} l√†:`;
                correct = supp;
                optionsList.push(getName(l[2], l[3]), "Kh√¥ng c√≥ g√≥c n√†o", getName(l[4], l[2]));
                explanation = `G√≥c k·ªÅ b√π c√≥ chung c·∫°nh $O${l[4]}$ v√† c·∫°nh c√≤n l·∫°i l√† tia ƒë·ªëi c·ªßa $O${l[1]}$ (l√† $O${l[0]}$).`;
            } 
            else { // H·ªèi k·ªÅ b√π TH·∫¨T (tr√°nh tia gi·∫£)
                const target = getName(l[2], l[1]);
                const supp = getName(l[2], l[0]);
                question = `G√≥c k·ªÅ b√π v·ªõi g√≥c ${target} l√†:`;
                correct = supp;
                optionsList.push(getName(l[4], l[1]), "Kh√¥ng c√≥ g√≥c n√†o", getName(l[3], l[0]));
                explanation = `G√≥c k·ªÅ b√π c√≥ chung c·∫°nh $O${l[2]}$ v√† c·∫°nh c√≤n l·∫°i l√† tia ƒë·ªëi c·ªßa $O${l[1]}$ (l√† $O${l[0]}$).`;
            }
            
            const options = shuffleArray([correct, ...optionsList]);
            return { typeLabel: "B·∫´y tia gi·∫£", text: question, correct, options, explanation, svg: drawing };
        };

        // 3. Nh·∫≠n di·ªán h√¨nh ·∫£nh (Visual Question) - C·∫¢I TI·∫æN H√åNH V·∫º
        const generateVisualIdentify = () => {
            const W = 400, H = 300;
            let svg = `<svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg" class="geometry-svg">`;
            
            const drawSubFig = (dx, dy, label, type) => {
                const cx = dx + 100;
                const cy = dy + 75;
                let s = "";
                s += `<rect x="${dx+10}" y="${dy+10}" width="180" height="130" fill="#f9fafb" stroke="#e5e7eb" rx="5" />`;
                s += `<text x="${dx+30}" y="${dy+30}" font-weight="bold" fill="#ea580c" font-size="14">${label}</text>`;
                
                if (type === 'correct_dd') { 
                    s += drawLine(cx-40, cy-30, cx+40, cy+30, "#333");
                    s += drawLine(cx-40, cy+30, cx+40, cy-30, "#333");
                    s += `<path d="M ${cx-15} ${cy-12} Q ${cx-20} ${cy} ${cx-15} ${cy+12}" fill="none" stroke="blue" />`;
                    s += `<path d="M ${cx+15} ${cy-12} Q ${cx+20} ${cy} ${cx+15} ${cy+12}" fill="none" stroke="blue" />`;
                } 
                else if (type === 'wrong_dd_ke') {
                    // K·ªÅ nh∆∞ng KH√îNG b√π v√† KH√îNG ƒë·ªëi ƒë·ªânh (g√≥c g√£y r√µ r√†ng)
                    s += drawLine(cx, cy, cx-40, cy, "#333"); // Ngang tr√°i
                    s += drawLine(cx, cy, cx+35, cy-35, "#333"); // Xi√™n l√™n ph·∫£i cao
                    s += drawLine(cx, cy, cx, cy+40, "#333"); // Xu·ªëng d∆∞·ªõi
                    // ƒê√°nh d·∫•u 2 g√≥c k·ªÅ nhau
                    s += `<path d="M ${cx-15} ${cy} Q ${cx-15} ${cy+15} ${cx} ${cy+15}" fill="none" stroke="red" />`; 
                    s += `<path d="M ${cx+10} ${cy-8} Q ${cx+15} ${cy+10} ${cx} ${cy+15}" fill="none" stroke="red" />`;
                }
                else if (type === 'wrong_dd_gay') { 
                    s += drawLine(cx-40, cy, cx+40, cy, "#333"); // Ngang
                    s += drawLine(cx, cy, cx-20, cy-35, "#333"); // L√™n tr√°i
                    s += drawLine(cx, cy, cx+30, cy+25, "#333"); // Xu·ªëng ph·∫£i l·ªách
                    s += `<path d="M ${cx-10} ${cy-5} Q ${cx-15} ${cy} ${cx-10} ${cy+5}" fill="none" stroke="red" />`;
                    s += `<path d="M ${cx+10} ${cy-5} Q ${cx+15} ${cy} ${cx+10} ${cy+5}" fill="none" stroke="red" />`;
                }
                else if (type === 'correct_kb') { 
                    s += drawLine(cx-50, cy, cx+50, cy, "#333"); 
                    s += drawLine(cx, cy, cx+20, cy-40, "#333");
                    s += `<path d="M ${cx+15} ${cy} A 15 15 0 0 0 ${cx+5} ${cy-12}" fill="none" stroke="green" />`;
                    s += `<path d="M ${cx-15} ${cy} A 15 15 0 0 1 ${cx+5} ${cy-12}" fill="none" stroke="green" />`;
                }
                else if (type === 'wrong_kb_roi') {
                    // Hai g√≥c r·ªùi nhau
                    s += drawLine(cx-40, cy, cx-10, cy-30, "#333");
                    s += drawLine(cx-40, cy, cx-10, cy+30, "#333");
                    
                    s += drawLine(cx+20, cy, cx+50, cy-30, "#333");
                    s += drawLine(cx+20, cy, cx+50, cy+30, "#333");
                }
                else if (type === 'wrong_dd_lech') { 
                    // Chung ƒë·ªânh nh∆∞ng c·∫°nh kh√¥ng th·∫≥ng h√†ng
                    s += drawLine(cx, cy, cx-30, cy-30, "#333");
                    s += drawLine(cx, cy, cx+30, cy+30, "#333"); // Th·∫≥ng 1 c·∫∑p
                    s += drawLine(cx, cy, cx-30, cy+20, "#333");
                    s += drawLine(cx, cy, cx+35, cy-10, "#333"); // L·ªách c·∫∑p 2
                    s += `<path d="M ${cx-10} ${cy} Q ${cx-15} ${cy} ${cx-10} ${cy}" fill="none" stroke="red" />`; 
                }
                return s;
            };

            const qType = Math.random() < 0.5 ? 'dd' : 'kb';
            let question, correctLabel, types, expl;

            if (qType === 'dd') {
                question = "H√¨nh n√†o d∆∞·ªõi ƒë√¢y bi·ªÉu di·ªÖn m·ªôt c·∫∑p g√≥c <b>ƒë·ªëi ƒë·ªânh</b>?";
                const wrongTypes = ['wrong_dd_ke', 'wrong_dd_gay', 'wrong_kb_roi', 'wrong_dd_lech'];
                const selectedWrongs = shuffleArray(wrongTypes).slice(0, 3);
                
                // --- FIX LOGIC RANDOM H√åNH ·∫¢NH ---
                // T·∫°o danh s√°ch lo·∫°i h√¨nh
                const typeList = ['correct_dd', selectedWrongs[0], selectedWrongs[1], selectedWrongs[2]];
                // X√°o tr·ªôn danh s√°ch n√†y
                shuffleArray(typeList);
                
                // X√°c ƒë·ªãnh v·ªã tr√≠ ƒë√∫ng
                const correctIndex = typeList.indexOf('correct_dd');
                correctLabel = `H√¨nh ${correctIndex + 1}`;
                
                expl = `H√¨nh ${correctIndex + 1} th·ªÉ hi·ªán hai ƒë∆∞·ªùng th·∫≥ng c·∫Øt nhau, t·∫°o th√†nh c·∫∑p g√≥c ƒë·ªëi ƒë·ªânh (c√°c c·∫°nh l√† tia ƒë·ªëi nhau). C√°c h√¨nh c√≤n l·∫°i kh√¥ng th·ªèa m√£n t√≠nh ch·∫•t tia ƒë·ªëi.`;
                
                // V·∫Ω
                svg += drawSubFig(0, 0, "H√¨nh 1", typeList[0]);
                svg += drawSubFig(200, 0, "H√¨nh 2", typeList[1]);
                svg += drawSubFig(0, 150, "H√¨nh 3", typeList[2]);
                svg += drawSubFig(200, 150, "H√¨nh 4", typeList[3]);

            } else {
                question = "H√¨nh n√†o d∆∞·ªõi ƒë√¢y bi·ªÉu di·ªÖn m·ªôt c·∫∑p g√≥c <b>k·ªÅ b√π</b>?";
                const typeList = ['correct_kb', 'correct_dd', 'wrong_dd_ke', 'wrong_kb_roi'];
                shuffleArray(typeList);
                
                const correctIndex = typeList.indexOf('correct_kb');
                correctLabel = `H√¨nh ${correctIndex + 1}`;
                expl = `H√¨nh ${correctIndex + 1} th·ªÉ hi·ªán hai g√≥c c√≥ chung m·ªôt c·∫°nh, hai c·∫°nh c√≤n l·∫°i l√† hai tia ƒë·ªëi nhau (t·∫°o th√†nh ƒë∆∞·ªùng th·∫≥ng), n√™n ch√∫ng l√† g√≥c k·ªÅ b√π.`;
                
                svg += drawSubFig(0, 0, "H√¨nh 1", typeList[0]);
                svg += drawSubFig(200, 0, "H√¨nh 2", typeList[1]);
                svg += drawSubFig(0, 150, "H√¨nh 3", typeList[2]);
                svg += drawSubFig(200, 150, "H√¨nh 4", typeList[3]);
            }

            svg += "</svg>";
            const options = ["H√¨nh 1", "H√¨nh 2", "H√¨nh 3", "H√¨nh 4"];
            return { typeLabel: "Nh·∫≠n di·ªán h√¨nh ·∫£nh", text: question, correct: correctLabel, options, explanation: expl, svg };
        };

        const generateComplex = () => {
            const r = Math.random();
            if (r < 0.4) return generateVisualIdentify();
            if (r < 0.7) return generateMultiLines();
            return generateFakeRays();
        };

        // --- CORE LOGIC ---
        const showLoading = () => {
            const loader = document.getElementById('question-loader');
            loader.classList.remove('hidden-loader');
        };

        const hideLoading = () => {
            const loader = document.getElementById('question-loader');
            loader.classList.add('hidden-loader');
        };

        const loadQuestion = () => {
            showLoading();
            const contentWrapper = document.getElementById('main-content-wrapper');
            contentWrapper.classList.remove('content-visible');

            state.isAnswered = false;
            let qData;
            
            let selectedMode = state.mode;
            if (state.mode === 'all') {
                const r = Math.random();
                if (r < 0.3) selectedMode = 'kebu';
                else if (r < 0.6) selectedMode = 'doidinh';
                else selectedMode = 'complex';
            }

            if (selectedMode === 'kebu') qData = generateKeBu();
            else if (selectedMode === 'doidinh') qData = generateDoiDinh();
            else qData = generateComplex();

            state.currentQuestion = qData;

            // Render UI
            document.getElementById('question-type-badge').innerText = qData.typeLabel;
            document.getElementById('question-text').innerHTML = qData.text;
            
            const imgContainer = document.getElementById('image-container');
            if (qData.svg) {
                imgContainer.innerHTML = qData.svg;
                imgContainer.classList.remove('hidden');
            } else {
                imgContainer.innerHTML = '';
                imgContainer.classList.add('hidden');
            }
            
            const optionsContainer = document.getElementById('options-container');
            optionsContainer.innerHTML = '';
            
            qData.options.forEach((opt, index) => {
                const btn = document.createElement('button');
                btn.className = "btn-option w-full bg-orange-50 hover:bg-orange-100 text-orange-900 border border-orange-200 p-4 rounded-xl text-lg font-semibold shadow-sm text-left flex items-center group";
                btn.dataset.value = opt; 

                const labels = ['A', 'B', 'C', 'D'];
                btn.innerHTML = `<span class="inline-block w-8 h-8 rounded-full bg-orange-200 text-center leading-8 mr-3 text-orange-800 font-bold shadow-sm group-hover:bg-orange-600 group-hover:text-white transition flex-shrink-0">${labels[index]}</span> <span>${opt}</span>`;
                btn.onclick = () => checkAnswer(opt, btn);
                optionsContainer.appendChild(btn);
            });

            document.getElementById('feedback-msg').className = "hidden";
            document.getElementById('explanation-area').className = "hidden mb-6 p-4 bg-yellow-50 border-l-4 border-yellow-400 rounded-r-lg text-gray-700 text-sm md:text-base fade-in";
            document.getElementById('explanation-area').innerHTML = '';
            
            const btnNext = document.getElementById('btn-next');
            btnNext.innerHTML = 'B·ªè qua <i class="fas fa-forward ml-2"></i>';
            btnNext.className = "bg-white border border-gray-300 text-gray-600 px-6 py-2 rounded-full font-bold hover:bg-orange-100 transition flex items-center ml-auto shadow-sm";

            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([contentWrapper]).then(() => {
                    setTimeout(() => {
                        hideLoading();
                        contentWrapper.classList.add('content-visible');
                    }, 150);
                });
            } else {
                setTimeout(() => {
                    hideLoading();
                    contentWrapper.classList.add('content-visible');
                }, 200);
            }
        };

        const checkAnswer = (selectedVal, btnElement) => {
            if (state.isAnswered) return;
            state.isAnswered = true;

            const isCorrect = selectedVal == state.currentQuestion.correct;
            const feedbackEl = document.getElementById('feedback-msg');
            const explArea = document.getElementById('explanation-area');
            const overlay = document.getElementById('feedback-overlay');
            const icon = document.getElementById('feedback-icon');
            const title = document.getElementById('feedback-title');
            const msg = document.getElementById('feedback-message');
            const detail = document.getElementById('feedback-detail');

            const allBtns = document.querySelectorAll('.btn-option');
            allBtns.forEach(b => {
                b.disabled = true;
                b.classList.add('opacity-70');
            });

            const correctBtn = Array.from(allBtns).find(b => b.dataset.value === state.currentQuestion.correct);
            if (correctBtn) {
                correctBtn.classList.remove('bg-orange-50', 'text-orange-900', 'border-orange-200', 'opacity-70');
                correctBtn.classList.add('bg-green-100', 'text-green-800', 'border-green-600', 'border-2', 'opacity-100');
                const span = correctBtn.querySelector('span');
                if(span) {
                    span.classList.remove('bg-orange-200', 'text-orange-800');
                    span.classList.add('bg-green-600', 'text-white');
                }
            }

            if (isCorrect) {
                btnElement.classList.add('bg-green-500', 'text-white', 'pop', 'opacity-100');
                btnElement.classList.remove('bg-green-100', 'text-green-800'); 
                const span = btnElement.querySelector('span');
                if(span) span.classList.add('bg-white', 'text-green-600');

                feedbackEl.innerHTML = `<span class="text-green-600"><i class="fas fa-check-circle"></i> Ch√≠nh x√°c!</span>`;
                feedbackEl.className = "text-lg font-bold block pl-2 animate-bounce";
                
                state.streak++;
                state.correct++;
            } else {
                btnElement.classList.add('bg-red-500', 'text-white', 'border-red-600', 'shake', 'opacity-100');
                btnElement.classList.remove('bg-orange-50');
                const span = btnElement.querySelector('span');
                if(span) span.classList.add('bg-white', 'text-red-600');
                
                feedbackEl.innerHTML = `<span class="text-red-500"><i class="fas fa-times-circle"></i> Ch∆∞a ƒë√∫ng!</span>`;
                feedbackEl.className = "text-lg font-bold block pl-2";

                state.streak = 0;
                state.wrong++;

                icon.innerHTML = '<i class="fas fa-times-circle text-red-500"></i>';
                title.innerText = "Ch∆∞a ch√≠nh x√°c";
                title.className = "text-2xl font-bold mb-2 text-red-600";
                msg.innerHTML = `ƒê√°p √°n ƒë√∫ng l√†: <br><span class="text-green-600 font-bold text-xl mt-2 block">${state.currentQuestion.correct}</span>`;
                
                setTimeout(() => { 
                    overlay.classList.remove('hidden'); 
                    if (window.MathJax) MathJax.typesetPromise([overlay]);
                }, 600);
            }

            renderStats();

            explArea.innerHTML = `<p class="font-bold text-orange-800 mb-1"><i class="fas fa-lightbulb text-yellow-500 mr-2"></i>Gi·∫£i th√≠ch:</p> ${state.currentQuestion.explanation}`;
            explArea.classList.remove('hidden');
            detail.innerHTML = state.currentQuestion.explanation;

            const btnNext = document.getElementById('btn-next');
            btnNext.innerHTML = `C√¢u ti·∫øp theo <i class="fas fa-arrow-right ml-2"></i>`;
            btnNext.className = "bg-orange-600 text-white px-6 py-2 rounded-full font-bold hover:bg-orange-700 transition flex items-center ml-auto shadow-lg transform scale-105";

            if (window.MathJax) MathJax.typesetPromise([explArea]);
        };

        const handleNextClick = (forceSkip = false) => {
            if (!state.isAnswered && !forceSkip) {
                state.streak = 0;
                state.skipped++;
                renderStats();
            }
            loadQuestion();
        };

        const renderStats = () => {
            const container = document.getElementById('stats-container');
            container.innerHTML = `
                <div class="flex flex-col items-center">
                    <span class="text-xs text-gray-500 uppercase font-bold">Chu·ªói th·∫Øng üî•</span>
                    <span class="text-3xl font-extrabold ${state.streak > 2 ? 'text-orange-500 animate-pulse' : 'text-gray-800'}">
                        ${state.streak}
                    </span>
                </div>
                <div class="flex flex-col items-center border-l">
                    <span class="text-xs text-gray-500 uppercase font-bold">ƒê√∫ng</span>
                    <span class="text-xl font-bold text-green-600">${state.correct}</span>
                </div>
                <div class="flex flex-col items-center border-l">
                    <span class="text-xs text-gray-500 uppercase font-bold">Sai</span>
                    <span class="text-xl font-bold text-red-500">${state.wrong}</span>
                </div>
                <div class="flex flex-col items-center border-l">
                    <span class="text-xs text-gray-500 uppercase font-bold">B·ªè qua</span>
                    <span class="text-xl font-bold text-gray-400">${state.skipped}</span>
                </div>
            `;
        };

        const setMode = (mode) => {
            state.mode = mode;
            ['all', 'kebu', 'doidinh', 'complex'].forEach(m => {
                const btn = document.getElementById(`btn-mode-${m}`);
                if (m === mode) {
                    btn.className = "mode-active py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform transform scale-105";
                } else {
                    btn.className = "mode-inactive py-2 px-1 rounded-lg font-bold border-2 shadow-sm text-xs md:text-sm flex flex-col items-center justify-center transition-transform";
                }
            });
            handleNextClick(true);
        };

        const closeModal = () => {
            document.getElementById('feedback-overlay').classList.add('hidden');
        };

        window.onload = () => {
            renderStats();
            loadQuestion();
        }
    </script>
</body>
</html>